<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>qi Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>


<div id="top"><!-- do not remove this div! -->
<div class="related">
  <ul>
    <!-- <li style="margin-right: 10px" class="right"> -->
    <!--   <a accesskey="I" title="General Index" href="genindex.html">index</a> -->
    <!-- </li> -->
    <!-- <li class="right"> -->
    <!--   <a accesskey="N" title="Whatâ€™s new?" href="news/whatsnew/index.html">next</a> | -->
    <!-- </li> -->
    <li><a href="../../index.html">Aldebaran documentation</a> |</li>
    <li><a href="../../ref/cpp-api.html">C++ Libraries</a> |</li>
    <li><a href="index.html">index</a></li>
  </ul>
</div>


<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libqi-api
   &#160;<span id="projectnumber">2.2.0.55</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">qi Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00450.html">detail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00451.html">details</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00365.html">log</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Log functions with different levels of verbosity. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00453.html">measure</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00454.html">os</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>OS abstraction layer. . </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00377.html">path</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Set of tools to handle SDK layouts. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00456.html">version</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><a class="el" href="a00331.html" title="Compare version strings Simple class that allow comparing two version number.">Version</a> numbering API. . </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">Actor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00329.html">VarArguments</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00330.html">VarArguments&lt; AnyValue &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">CallableTypeInterface</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00270.html">Signature</a> information for both callable types <a class="el" href="a00202.html">FunctionTypeInterface</a> and MethodType.  <a href="a00038.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html">FunctionTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">ArgumentTransformation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00222.html">KeywordArguments</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">AnyArguments</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function with <a class="el" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a> as its sole argument will behave as if <a class="el" href="a00020.html#af84daf701221e75612b814b823f7a91b">AnyFunction::fromDynamicFunction</a> was called.  <a href="a00019.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">AnyFunction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html">GenericFunctionParameters</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">ModuleInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">AnyModule</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">ModuleBuilder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">Application</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class handling startup and teardown of an application.  <a href="a00025.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">ApplicationSession</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">Atomic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">ObjectSerializationInfo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Informations passed when serializing an object.  <a href="a00244.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00273.html">StreamContext</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">Buffer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to store buffer. .  <a href="a00036.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">BufferReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to read const buffer.  This class is intendeed to read buffer. It store an internal data cursor and an internal sub-buffer index. All offset are relative to the current position.  <a href="a00037.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html">SteadyClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00271.html" title="The SteadyClock class represents a monotonic clock.  &lt;includename&gt;qi/clock.hpp&lt;/includename&gt; ...">SteadyClock</a> class represents a monotonic clock. .  <a href="a00271.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00332.html">WallClock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00332.html" title="The WallClock class represents the system-wide real time wall clock. It may not be monotonic: on most...">WallClock</a> class represents the system-wide real time wall clock. It may not be monotonic: on most systems, the system time can be adjusted at any moment.  <a href="a00332.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">ExecutionContext</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">FutureValueConverter&lt; void, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">FutureValueConverter&lt; T, void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">FutureValueConverter&lt; void, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">FutureException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">FutureUserException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">Future</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">FutureSync</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">Promise</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">FutureBarrier</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps waiting on multiple futures at the same point.  <a href="a00204.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">FutureValueConverter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize this struct to provide conversion between future values.  <a href="a00208.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">EventLoop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to handle eventloop. .  <a href="a00197.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">AutoService</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">AutoService&lt; qi::AnyObject &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">Gateway</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html">RemoteGateway</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00263.html">ReverseGateway</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">ServiceInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00250.html">Path</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00250.html" title="The Path class allow handling path in a cross-platform maner.  &lt;includename&gt;qi/path.hpp&lt;/includename&gt;  The class assume that all string are encoded in UTF-8.">Path</a> class allow handling path in a cross-platform maner.  The class assume that all string are encoded in UTF-8.  <a href="a00250.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">DataPerf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to compute and store a benchmark time.  <a href="a00039.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">DataPerfSuite</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to perform benchmarks.  <a href="a00040.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00251.html">PeriodicTask</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Control a task executed periodically and asynchronously. .  <a href="a00251.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00257.html">PropertyBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">PropertyImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00255.html">Property</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00256.html">Property&lt; AnyValue &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html">GenericProperty</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased property, simulating a typed property but using <a class="el" href="a00024.html">AnyValue</a>.  <a href="a00217.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">Session</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">SignalBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">SignalF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">Signal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00269.html">SignalSubscriber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html">Signature</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">MinMaxSum</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores min, max and sum of values fed to it.  <a href="a00241.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00240.html">MethodStatistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Store statistics about method calls.  <a href="a00240.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">Strand</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00282.html">TrackableBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class to templates <a class="el" href="a00281.html" title="Object tracking by blocking destruction while shared pointers are present.">Trackable</a> for compile-time detection.  <a href="a00282.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00281.html">Trackable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00015.html">Object</a> tracking by blocking destruction while shared pointers are present.  <a href="a00281.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html">PointerLockException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00283.html">Translator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Localization of your source code.  <a href="a00283.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">InfosKeyMask</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">FunctionTypeInterfaceEq</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">AnyIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">AnyReference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">AutoAnyReference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">AnyValue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00294.html">TypeImpl&lt; AnyValue &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">FutureValueConverter&lt; T, qi::AnyValue &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">FutureValueConverter&lt; void, qi::AnyValue &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">boost_bind_result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">boost_bind_result_type&lt; boost::_bi::bind_t&lt; R, A, B &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">boost_bind_parameter_types</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">boost_bind_parameter_types&lt; boost::_bi::bind_t&lt; R, F, B &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">boost_bind_function_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html">TypeBufferImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html">TypeImpl&lt; Buffer &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00295.html">TypeImpl&lt; boost::any &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">GenericObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00296.html">TypeImpl&lt; boost::shared_ptr&lt; GenericObject &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00220.html">IntTypeInterfaceImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00284.html">TypeBoolImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">FloatTypeInterfaceImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">ListTypeInterfaceImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00325.html">TypeSimpleIteratorImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00310.html">TypeImpl&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00305.html">TypeImpl&lt; std::list&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00308.html">TypeImpl&lt; std::set&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00328.html">VarArgsTypeInterfaceImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00304.html">TypeImpl&lt; qi::VarArguments&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">EventTrace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html">Manageable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">MapTypeInterfaceImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00306.html">TypeImpl&lt; std::map&lt; K, V, C, A &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">Empty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">Object</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00333.html">WeakObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00301.html">TypeImpl&lt; Object&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00254.html">PointerTypeInterfaceImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00312.html">TypeImpl&lt; T * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00324.html">TypeSharedPointerImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00297.html">TypeImpl&lt; boost::shared_ptr&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html">Proxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00322.html">TypeProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00323.html">TypeProxyWrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html">StringTypeInterfaceImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00309.html">TypeImpl&lt; std::string &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00291.html">TypeCStringImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00299.html">TypeImpl&lt; char * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00300.html">TypeImpl&lt; char[I]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00292.html">TypeEquivalentString</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html">StructTypeInterfaceBouncer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00307.html">TypeImpl&lt; std::pair&lt; F, S &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html">TraceAnalyzer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html">TemplateTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00316.html">TypeOfTemplate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00317.html">TypeOfTemplateDefaultImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00318.html">TypeOfTemplateImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00286.html">TypeByPointer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access API that stores a T* in storage.  <a href="a00286.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00287.html">TypeByPointer&lt; const T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00288.html">TypeByPointerPOD</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00289.html">TypeByValue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access api that stores a T in storage.  <a href="a00289.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html">TypeByValue&lt; const T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">DefaultTypeImplMethods</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">DefaultTypeImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00293.html">TypeImpl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00313.html">TypeImpl&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00311.html">TypeImpl&lt; T &amp; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00314.html">TypeInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00315.html">TypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">DynamicObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">DynamicObjectBuilder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">MetaMethodParameter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">MetaMethod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a method in an <a class="el" href="a00216.html">GenericObject</a>.  <a href="a00233.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00234.html">MetaMethodBuilder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html">MetaObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of the signals and methods accessible on an <a class="el" href="a00247.html">ObjectTypeInterface</a>.  <a href="a00236.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">MetaObjectBuilder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00238.html">MetaProperty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html">MetaSignal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a <a class="el" href="a00266.html">Signal</a> in an <a class="el" href="a00216.html">GenericObject</a>.  <a href="a00239.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00246.html">ObjectTypeBuilderBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html">ObjectTypeBuilder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00319.html">TypeOfTemplateImpl&lt; qi::Future, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00320.html">TypeOfTemplateImpl&lt; qi::FutureSync, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00321.html">TypeOfTemplateImpl&lt; qi::Promise, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html">ProxyProperty</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">ProxySignal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00266.html">Signal</a> proxy, using an AnyObject and signal id as backend.  <a href="a00260.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">IntTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00200.html">FloatTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00274.html">StringTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00261.html">RawTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00253.html">PointerTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00221.html">IteratorTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">ListTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">MapTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html">StructTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">DynamicTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00327.html">VarArgsTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html">TypeImpl&lt; qi::TypeInterface &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00302.html">TypeImpl&lt; qi::TypeInterface * &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00247.html">ObjectTypeInterface</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00326.html">Url</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00329.html">VarArguments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ac2ed3fa7ace03e256bedcccb7eda2917">AnyVarArguments</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function<br class="typebreak"/>
&lt; <a class="el" href="a00023.html">AnyReference</a>(const <br class="typebreak"/>
<a class="el" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aa61ce87899c4efa29126c580a4ee808f">DynamicFunction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function<br class="typebreak"/>
&lt; <a class="el" href="a00022.html">AnyModule</a>(const <br class="typebreak"/>
<a class="el" href="a00243.html">qi::ModuleInfo</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#afdd4334b0f48a51c9a138024efc8f19c">ModuleFactoryFunctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00015.html">Object</a>&lt; <a class="el" href="a00196.html">Empty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#aba08c16e9fd5810e6475a0c8e1dfa3c3">qi::uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a684b8e9b61abeca94f79afd1fa961794">ApplicationSessionOptions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
<a class="el" href="a00024.html">AnyValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a61807322c399d9d4c3483626e7b58bfe">CapabilityMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>(const <br class="typebreak"/>
<a class="el" href="a00244.html">ObjectSerializationInfo</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ac26bb2a65903f833b31e13a1eb4736f6">DeserializeObjectCallback</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of callback invoked by sdeerializer when it encounters an object.  <a href="#ac26bb2a65903f833b31e13a1eb4736f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function<br class="typebreak"/>
&lt; <a class="el" href="a00244.html">ObjectSerializationInfo</a>(const <br class="typebreak"/>
<a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a5875da1c0d54d3fa979c19ccb88253fa">SerializeObjectCallback</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of callback invoked by serializer when it encounters an object.  <a href="#a5875da1c0d54d3fa979c19ccb88253fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::chrono::duration<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::nano &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">Duration</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedefs.  <a href="#aa5d4c066f262dfde002d18537d30260e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::chrono::duration<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::nano &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a037ade806630690498a71c88f48611a0">NanoSeconds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::chrono::duration<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::micro &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aba135b1052ec59022ce6a7bdbd6268c1">MicroSeconds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::chrono::duration<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::milli &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a65b3b7288a6892c01caae62907d31c62">MilliSeconds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::chrono::duration<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a463a99b0e8740a136d135f3c305f892e">Seconds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::chrono::duration<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::ratio&lt; 60 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a5014ba6f659bada6e21717ea77c0a73d">Minutes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
boost::chrono::duration<br class="typebreak"/>
&lt; <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::ratio&lt; 3600 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a22d0bee7d7642c80bcef42ed0b734945">Hours</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00271.html#a8bb7553fd66a3301bafa2fb9fd3fce14">SteadyClock::SteadyClockTimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ab752bd54724652b6a0b86bd680b434de">SteadyClockTimePoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Steady clock time point.  <a href="#ab752bd54724652b6a0b86bd680b434de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="a00332.html#a63b19738a9e6d9e69090d8792e4b30c5">WallClock::WallClockTimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a739c9431170590d38d2bde9cf595d474">WallClockTimePoint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wall clock time point.  <a href="#a739c9431170590d38d2bde9cf595d474"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a96c761b741f387d89021e8a3d96a7506">LogContext</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs context attribute value.  <a href="#a96c761b741f387d89021e8a3d96a7506"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00029.html">AutoService</a>&lt; <a class="el" href="a00196.html">qi::Empty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a9a26927d76f789c14adedacf26533218">AnyAutoService</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00264.html">qi::ServiceInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a30c4304ccd890650e355902dd160d180">ServiceInfoVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="a00250.html">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ad3f0d036edc4edebd2bf5cb09eaf99d9">PathVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::codecvt&lt; wchar_t, <br class="typebreak"/>
char, std::mbstate_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ad285b93d0b3fd990de2df5bb7ea893bd">codecvt_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard std::codecvt type accepted by STL and boost.  <a href="#ad285b93d0b3fd990de2df5bb7ea893bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00265.html">Session</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ae3f87eaf6b8d541402a41d14a8b33816">SessionPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#a2ee81d854cc30ed5de683db744436323">qi::uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a69247b0b30dc5f6df95488f18e9aff01">SignalLink</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00269.html">SignalSubscriber</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a3d3f787f311e8225a14aa23d0050a396">SignalSubscriberPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="a00270.html">Signature</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aa71087a4ad8ea509d34fb98bb1c9e2dd">SignatureVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="a00023.html">AnyReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="a00024.html">AnyValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a9fc9c029f3e47daa5e331a46afca298b">AnyValueVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; unsigned int, <br class="typebreak"/>
<a class="el" href="a00240.html">MethodStatistics</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a8b5a1cd8421b582197e3819ac1f12f6f">ObjectStatistics</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00333.html">WeakObject</a>&lt; <a class="el" href="a00196.html">Empty</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a984d5fa8d8f50699c31a3da9bca5b63a">AnyWeakObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00235.html">MetaMethodParameter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a5ed86b325a1733ad7dca7f94f60b80c7">MetaMethodParameterVector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#a80fe74541b93ef969ff854a4e2e567e1">int8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a80fe74541b93ef969ff854a4e2e567e1">int8_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform signed integer of length 8 bits (1 byte).  <a href="#a80fe74541b93ef969ff854a4e2e567e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#ad7166635ba92d23bff55b96338775dcb">int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ad7166635ba92d23bff55b96338775dcb">int16_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform signed integer of length 16 bits (2 bytes).  <a href="#ad7166635ba92d23bff55b96338775dcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#a2ed30d0c39356a44feabae5054779c42">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a2ed30d0c39356a44feabae5054779c42">int32_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform signed integer of length 32 bits (4 bytes).  <a href="#a2ed30d0c39356a44feabae5054779c42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform signed integer of length 64 bits (8 bytes).  <a href="#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#a1c41798686ce92a711a18be804316988">uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a1c41798686ce92a711a18be804316988">uint8_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform unsigned integer of length 8 bits (1 byte).  <a href="#a1c41798686ce92a711a18be804316988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#ac7b1d8a9d9dfe41eaf074e2428c13e4b">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ac7b1d8a9d9dfe41eaf074e2428c13e4b">uint16_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform unsigned integer of length 16 bits (2 bytes).  <a href="#ac7b1d8a9d9dfe41eaf074e2428c13e4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#aba08c16e9fd5810e6475a0c8e1dfa3c3">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aba08c16e9fd5810e6475a0c8e1dfa3c3">uint32_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform unsigned integer of length 32 bits (4 bytes).  <a href="#aba08c16e9fd5810e6475a0c8e1dfa3c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00359.html#a2ee81d854cc30ed5de683db744436323">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a2ee81d854cc30ed5de683db744436323">uint64_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform unsigned integer of length 64 bits (8 bytes).  <a href="#a2ee81d854cc30ed5de683db744436323"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="a00326.html">Url</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a60eaea69ef2b87575875e6e82fd6d60f">UrlVector</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a06fde6361c5d179ff0b9615a0ac4aa51">FutureState</a> { <br/>
&#160;&#160;<a class="el" href="a00359.html#a06fde6361c5d179ff0b9615a0ac4aa51a7353b65c14fc6205a79798a3fbd4401a">FutureState_None</a>, 
<a class="el" href="a00359.html#a06fde6361c5d179ff0b9615a0ac4aa51ab4aa09c0a00d9b24933df2952b28bc15">FutureState_Running</a>, 
<a class="el" href="a00359.html#a06fde6361c5d179ff0b9615a0ac4aa51a3c3a4f9e8d394891d5717e8e962ce8f9">FutureState_Canceled</a>, 
<a class="el" href="a00359.html#a06fde6361c5d179ff0b9615a0ac4aa51a8a7110a297926cba1ba38f5272a1ba5d">FutureState_FinishedWithError</a>, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#a06fde6361c5d179ff0b9615a0ac4aa51aa34f218f2ec9a05027f11f7e524cef0b">FutureState_FinishedWithValue</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a66922f30da6f5708915f47ed330e0de0">FutureCallbackType</a> { <a class="el" href="a00359.html#a66922f30da6f5708915f47ed330e0de0a994de07b744ad919d45ec8666da03c4f">FutureCallbackType_Sync</a> =  0, 
<a class="el" href="a00359.html#a66922f30da6f5708915f47ed330e0de0adee2428ef5a90f515ac7737c9a159d75">FutureCallbackType_Async</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ad1f54e93f8719f4708669496c8a20a9c">FutureTimeout</a> { <a class="el" href="a00359.html#ad1f54e93f8719f4708669496c8a20a9ca648162635a9fcbc69da607a51197e07c">FutureTimeout_Infinite</a> =  ((int) 0x7fffffff), 
<a class="el" href="a00359.html#ad1f54e93f8719f4708669496c8a20a9caa418e4954620069c7ddbb4bc6c1e661d">FutureTimeout_None</a> =  0
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321">StreamColor</a> { <br/>
&#160;&#160;<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a344631221068a24cef3301551065bc00">StreamColor_None</a> =  0, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321aa5ae1a9eb8c9ca2c0427682808b5b3a8">StreamColor_Reset</a> =  1, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a4f2f77f9392a206c386c1e89422e3152">StreamColor_Bold</a> =  2, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321aac8b681a7977a3d0a07ffcee0b99d5af">StreamColor_Faint</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a67fec5cb524c9c012d15a814833b1e57">StreamColor_Standout</a> =  4, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a4715eae0b58f7aa8cb08adfa6b5788b9">StreamColor_Underline</a> =  5, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a9f4660fb42a98a264060e46d5ba396b8">StreamColor_Blink</a> =  6, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321ab5ad1ee5aa153c51cb41d78ba91632a1">StreamColor_Overline</a> =  7, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a43a4c4c728f3f852cdb6e454ef918824">StreamColor_Black</a> =  8, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a67c34ed466def0e9a5dbf1da90fedde0">StreamColor_DarkRed</a> =  9, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a16f2e3b9e225ef941f0fe8b5a8a6f79c">StreamColor_DarkGreen</a> =  10, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a68b0b8fdcb78a4b2f8bd9eabf244efaa">StreamColor_Brown</a> =  11, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a1c64bda3e21fa88c070db2ac2bcd6bd5">StreamColor_DarkBlue</a> =  12, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321af937c4634377d7684ecbe385807e6c37">StreamColor_Purple</a> =  13, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a94a58a580a0576ea1f28a2564774f95a">StreamColor_Teal</a> =  14, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a6352965a77351604a4fb449f66df96e6">StreamColor_LightGray</a> =  15, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321af8cbac1491dc0aa4350d410c7979610a">StreamColor_DarkGray</a> =  16, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a0191c01a1ae8a0f32513e6d435a035b4">StreamColor_Red</a> =  17, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a7fb90bd6188ea53c9f501f07278639dc">StreamColor_Green</a> =  18, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321ab65ac4782da71d06fc5033877df7a342">StreamColor_Yellow</a> =  19, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a49b1c68c9ae2782eb143a3a66dae3d55">StreamColor_Blue</a> =  20, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321a68b9f3474d708de9bbbcfa8ee81f822b">StreamColor_Fuchsia</a> =  21, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321ac19037b0d7b1c1a760e7182f3b598091">StreamColor_Turquoise</a> =  22, 
<a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321af2db4cdda545b6e45843235be74f637f">StreamColor_White</a> =  23
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Stream Color enum.  <a href="a00359.html#a118f2d350ecce997af3f9e1c817fa321">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5">LogLevel</a> { <br/>
&#160;&#160;<a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5a77059e55763f4584259218f0802d6b58">LogLevel_Silent</a> =  0, 
<a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5ab7f68198dd8bff433614815c8a226fc8">LogLevel_Fatal</a>, 
<a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5a29568c44b55d44dec768128135f45d4a">LogLevel_Error</a>, 
<a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5a1f5fad47e4e5cef1a8d437f94b9cc56f">LogLevel_Warning</a>, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5ab813d452a834cc8990cde0a8592c9f8d">LogLevel_Info</a>, 
<a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5a990d6cb9c4c1d0557c2e3780ae345839">LogLevel_Verbose</a>, 
<a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5a030864da44cde81392a2e2fbd2f33b1e">LogLevel_Debug</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Log level verbosity.  <a href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aa1d7c0b8007b1ab09fc2de493108396b">LogColor</a> { <a class="el" href="a00359.html#aa1d7c0b8007b1ab09fc2de493108396ba3bd8da8f7b698c20476796110d4647a1">LogColor_Never</a>, 
<a class="el" href="a00359.html#aa1d7c0b8007b1ab09fc2de493108396ba6057d0099587041711b20c47580e79b0">LogColor_Auto</a>, 
<a class="el" href="a00359.html#aa1d7c0b8007b1ab09fc2de493108396ba691067550d59a0e744b04b4bb782e829">LogColor_Always</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs color mode.  <a href="a00359.html#aa1d7c0b8007b1ab09fc2de493108396b">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88">LogContextAttr</a> { <br/>
&#160;&#160;<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88a7de8d9712806cce940066df9c298dde6">LogContextAttr_None</a> =  0, 
<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88aa98c7a6e68d61670619e925a6030850a">LogContextAttr_Verbosity</a> =  1 &lt;&lt; 0, 
<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88a5082e95ca9152e6dd0c45acccef85dea">LogContextAttr_ShortVerbosity</a> =  1 &lt;&lt; 1, 
<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88abe8c8facb4ddf7e7cf8e362db8101e53">LogContextAttr_Date</a> =  1 &lt;&lt; 2, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88a7dd9f2a728db294bbccab4452d97a718">LogContextAttr_Tid</a> =  1 &lt;&lt; 3, 
<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88ace5552c93742d5968ed2e9551317c06b">LogContextAttr_Category</a> =  1 &lt;&lt; 4, 
<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88a8b875514dd1c415afa9d92c9ca2a8e76">LogContextAttr_File</a> =  1 &lt;&lt; 5, 
<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88add0679d327681fecef744811c7a3fdbf">LogContextAttr_Function</a> =  1 &lt;&lt; 6, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88ab137c7cf28a44e366b6d2e6ec675587f">LogContextAttr_Return</a> =  1 &lt;&lt; 7
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs context attribute.  <a href="a00359.html#aeb49003e94f0efc86109a278d8d55f88">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a8d59aed9fc0a2b4ee91991e2888d0227">ObjectThreadingModel</a> { <a class="el" href="a00359.html#a8d59aed9fc0a2b4ee91991e2888d0227a56239778f0c7fc1f4ab6207862e81fbc">ObjectThreadingModel_SingleThread</a> =  0, 
<a class="el" href="a00359.html#a8d59aed9fc0a2b4ee91991e2888d0227a6551c85d1e42bb6cff437d35ee1661cc">ObjectThreadingModel_MultiThread</a> =  1, 
<a class="el" href="a00359.html#a8d59aed9fc0a2b4ee91991e2888d0227a4b1933f8429b66806e8387c1aff33cfd">ObjectThreadingModel_Default</a> =  ObjectThreadingModel_SingleThread
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible thread models for an object.  <a href="a00359.html#a8d59aed9fc0a2b4ee91991e2888d0227">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83">TypeKind</a> { <br/>
&#160;&#160;<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a9addb80987fbf6aba929a8ba36a8696a">TypeKind_Unknown</a> =  0, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a697124369f8d09989eb1799cc5b417f1">TypeKind_Void</a> =  1, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a5c9f02f8fde69ebf4ef298429f406ca1">TypeKind_Int</a> =  2, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83ac2cb42a5ad96ca81820b32883ff11ce1">TypeKind_Float</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a0cea76e7d2e7ca23952106e2df8e5477">TypeKind_String</a> =  4, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a2d80d8ac34eb816f880492fd48fa9947">TypeKind_List</a> =  5, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a02c298fe28a07aa0fd52762c6ead1f49">TypeKind_Map</a> =  6, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a3fdef608736434b0ed3db23409166f45">TypeKind_Object</a> =  7, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83ac588aa7668f30929b99f7b51e164d85e">TypeKind_Pointer</a> =  8, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83ae256bb50e674644be82c9e3c875b17b1">TypeKind_Tuple</a> =  9, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83ad4857d8288ae9b6587dbbe3a60afb7b1">TypeKind_Dynamic</a> =  10, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a629950116208ae3ec5707f826f77394a">TypeKind_Raw</a> =  11, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a053d4b330c4a9e259ddedd9bd8571ba3">TypeKind_Iterator</a> =  13, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a93d64a5491fde8c3736899b963ed84b6">TypeKind_Function</a> =  14, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83ade474d4acfbe0a14655b407dde022904">TypeKind_Signal</a> =  15, 
<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a657d2054debc55771add5e8c42987a26">TypeKind_Property</a> =  16, 
<br/>
&#160;&#160;<a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83a94150a53653301f2fefce04752093ef9">TypeKind_VarArgs</a> =  17
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#af26fc7fa51e2905573cda6a194af6cae">MetaCallType</a> { <a class="el" href="a00359.html#af26fc7fa51e2905573cda6a194af6caea0427d0d572be1d1929de10cb006946e8">MetaCallType_Auto</a> =  0, 
<a class="el" href="a00359.html#af26fc7fa51e2905573cda6a194af6caea90daab2e41b08efb5341e827e543ebbc">MetaCallType_Direct</a> =  1, 
<a class="el" href="a00359.html#af26fc7fa51e2905573cda6a194af6caea44b53fab14f133a377cfa684c4921b08">MetaCallType_Queued</a> =  2
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00202.html">FunctionTypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#af824fdaacc150d8140e14cedebc08f8d">makeFunctionTypeInterface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00202.html">FunctionTypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a098783b698f8b1042afa3fcb13fb2d75">dynamicFunctionTypeInterface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a1f39390146087e0629f56a47773afee0">registerCppEmbeddedModule</a> (const std::string &amp;moduleName, boost::function&lt; void(<a class="el" href="a00242.html">ModuleBuilder</a> *)&gt; fun)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00243.html">ModuleInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#af68bfc01c21c9742b95d9cd5dbfd383f">listModules</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00022.html">AnyModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a5882f25a3446993872bf1203d8ac5243">import</a> (const std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00022.html">AnyModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ac2d8256b364ab12d3b96d6bb3832b60e">import</a> (const <a class="el" href="a00243.html">ModuleInfo</a> &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a726e9946485acd3c5125ab71981d964b">registerModuleFactory</a> (const std::string &amp;name, <a class="el" href="a00359.html#afdd4334b0f48a51c9a138024efc8f19c">ModuleFactoryFunctor</a> fun)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00010.html">qi::Future</a>&lt; <a class="el" href="a00023.html">AnyReference</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aab97cd68b446e79163130ece29d2c5f0">metaCall</a> (<a class="el" href="a00199.html">ExecutionContext</a> *ec, <a class="el" href="a00359.html#a8d59aed9fc0a2b4ee91991e2888d0227">ObjectThreadingModel</a> objectThreadingModel, <a class="el" href="a00359.html#af26fc7fa51e2905573cda6a194af6cae">MetaCallType</a> methodThreadingModel, <a class="el" href="a00359.html#af26fc7fa51e2905573cda6a194af6cae">MetaCallType</a> callType, <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> manageable, unsigned int methodId, <a class="el" href="a00020.html">AnyFunction</a> func, const <a class="el" href="a00215.html">GenericFunctionParameters</a> &amp;params, bool noCloneFirst=false, unsigned int callerId=0, <a class="el" href="a00249.html">qi::os::timeval</a> postTimestamp=<a class="el" href="a00249.html">qi::os::timeval</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#af55c8cbcb460492f02918d9f5a8cb3be">testAndSet</a> (long *cond)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a17b1ac2d7a040d3644e751eb1bc602ed">decodeBinary</a> (<a class="el" href="a00037.html">qi::BufferReader</a> *buf, T *value, <a class="el" href="a00359.html#ac26bb2a65903f833b31e13a1eb4736f6">DeserializeObjectCallback</a> onObject=<a class="el" href="a00359.html#ac26bb2a65903f833b31e13a1eb4736f6">DeserializeObjectCallback</a>(), <a class="el" href="a00273.html">StreamContext</a> *streamContext=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#afb540c3b6650f31ca7695cb2bccd69cb">encodeBinary</a> (<a class="el" href="a00036.html">qi::Buffer</a> *buf, const <a class="el" href="a00028.html">AutoAnyReference</a> &amp;gvp, <a class="el" href="a00359.html#a5875da1c0d54d3fa979c19ccb88253fa">SerializeObjectCallback</a> onObject=<a class="el" href="a00359.html#a5875da1c0d54d3fa979c19ccb88253fa">SerializeObjectCallback</a>(), <a class="el" href="a00273.html">StreamContext</a> *ctx=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a71cf39de46afdc30a510d03200dc6ea2">decodeBinary</a> (<a class="el" href="a00037.html">qi::BufferReader</a> *buf, <a class="el" href="a00023.html">AnyReference</a> gvp, <a class="el" href="a00359.html#ac26bb2a65903f833b31e13a1eb4736f6">DeserializeObjectCallback</a> onObject=<a class="el" href="a00359.html#ac26bb2a65903f833b31e13a1eb4736f6">DeserializeObjectCallback</a>(), <a class="el" href="a00273.html">StreamContext</a> *ctx=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00359.html#ab752bd54724652b6a0b86bd680b434de">SteadyClockTimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a84baf7f5923e7dff446646a210cfdbf1">steadyClockNow</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00359.html#a739c9431170590d38d2bde9cf595d474">WallClockTimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a04b07a98ec099f7d8e14637d2d7dc531">wallClockNow</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a86d3fe036a58d21b7fe41fb71bf4cd95">nullConverter</a> (void *, R &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00010.html">qi::Future</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#ad14f72235d0dd750a72c972d59d6531a">makeFutureError</a> (const std::string &amp;error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to return a future with the error set.  <a href="#ad14f72235d0dd750a72c972d59d6531a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#ae3afa109040d75d6c2dabcb08001e9fe">waitForAll</a> (std::vector&lt; <a class="el" href="a00010.html">Future</a>&lt; T &gt; &gt; &amp;vect)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to wait on a vector of futures.  <a href="#ae3afa109040d75d6c2dabcb08001e9fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00206.html">qi::FutureSync</a>&lt; <a class="el" href="a00010.html">qi::Future</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#aa071177a4b92a882b1d5359cddc17a5e">waitForFirst</a> (std::vector&lt; <a class="el" href="a00010.html">Future</a>&lt; T &gt; &gt; &amp;vect)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to wait for the first valid future.  <a href="#aa071177a4b92a882b1d5359cddc17a5e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FT , typename PT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#ae3ab25935968b983ded9bf5211a9b173">adaptFuture</a> (const <a class="el" href="a00010.html">Future</a>&lt; FT &gt; &amp;f, <a class="el" href="a00016.html">Promise</a>&lt; PT &gt; &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Feed a promise from a future of possibly different type.  <a href="#ae3ab25935968b983ded9bf5211a9b173"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FT , typename PT , typename CONV &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#afcd48f3c1a84d796d798e757cc12e2b8">adaptFuture</a> (const <a class="el" href="a00010.html">Future</a>&lt; FT &gt; &amp;f, <a class="el" href="a00016.html">Promise</a>&lt; PT &gt; &amp;p, CONV converter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to adaptFuture(f, p) but with a custom converter.  <a href="#afcd48f3c1a84d796d798e757cc12e2b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#ac7c925ffbdf318146bade10e2ef6f64f">PromiseNoop</a> (const <a class="el" href="a00016.html">qi::Promise</a>&lt; T &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that does nothing on future cancellation.  <a href="#ac7c925ffbdf318146bade10e2ef6f64f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , typename ARG0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#af68a5d1f435c85272a104accccbc3d8e">track</a> (const boost::function&lt; F &gt; &amp;f, const ARG0 &amp;arg0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="a00281.html" title="Object tracking by blocking destruction while shared pointers are present.">Trackable</a> instance.  <a href="#af68a5d1f435c85272a104accccbc3d8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename F , typename ARG0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#af41c3c455c1fc41a160ea836c10947e2">trackWithFallback</a> (boost::function&lt; void()&gt; onFail, const boost::function&lt; F &gt; &amp;f, const ARG0 &amp;arg0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="a00281.html" title="Object tracking by blocking destruction while shared pointers are present.">Trackable</a> instance.  <a href="#af41c3c455c1fc41a160ea836c10947e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00197.html">EventLoop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ac6a56d0b369a9a5eeb3655db91c684c4">getEventLoop</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global eventloop, created on demand on first call.  <a href="#ac6a56d0b369a9a5eeb3655db91c684c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00010.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">async</a> (boost::function&lt; R()&gt; callback, <a class="el" href="a00359.html#a2ee81d854cc30ed5de683db744436323">uint64_t</a> usDelay=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00010.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#af9c797a4346eb3238c8f666f3450d6b0">async</a> (boost::function&lt; R()&gt; callback, <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">qi::Duration</a> delay)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00010.html">Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a921f4c45f023391fa581f83cc75734bc">async</a> (boost::function&lt; R()&gt; callback, <a class="el" href="a00359.html#ab752bd54724652b6a0b86bd680b434de">qi::SteadyClockTimePoint</a> timepoint)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename R , typename Func , typename ArgTrack &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00010.html">qi::Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a989ea5d8d0b3bfb75e1daefb30252071">async</a> (const Func &amp;f, const ArgTrack &amp;toTrack,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a5eeed22e4f35d2e93eac1fec0ff4dd48">startEventLoop</a> (int nthread)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the eventloop with nthread threads. No-op if already started.  <a href="#a5eeed22e4f35d2e93eac1fec0ff4dd48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boost::asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aa3ee2a95759c087e0cdadbe608a1ac59">getIoService</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the io_service used by the global event loop.  <a href="#aa3ee2a95759c087e0cdadbe608a1ac59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a320299dc29443998767ead43d180da8b">encodeJSON</a> (const <a class="el" href="a00028.html">qi::AutoAnyReference</a> &amp;val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00024.html">qi::AnyValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#abc0f8ab49ff6d865e791e8fd84ffa212">decodeJSON</a> (const std::string &amp;in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aefbddfd2b5c63e97a33bb1f4583a64ad">decodeJSON</a> (const std::string::const_iterator &amp;begin, const std::string::const_iterator &amp;end, <a class="el" href="a00024.html">AnyValue</a> &amp;target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00359.html#ad285b93d0b3fd990de2df5bb7ea893bd">codecvt_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a8a4809b2a654f168ec5c75609ebc04c1">unicodeFacet</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 facet object getter.  <a href="#a8a4809b2a654f168ec5c75609ebc04c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00359.html#ae3f87eaf6b8d541402a41d14a8b33816">SessionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a36e685d2199df078c6aa5524943776d7">makeSession</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a8199ee4e592ad4e5a704d44eefac588b">signatureSplit</a> (const std::string &amp;fullSignature)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00270.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a57e7b45e3cfcd1b27585b5776c268642">makeTupleSignature</a> (const std::vector&lt; <a class="el" href="a00023.html">qi::AnyReference</a> &gt; &amp;vgv, bool resolveDynamic=false, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00270.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aa0f39be2e53755f32bc54f278b92f6dc">makeTupleSignature</a> (const std::vector&lt; <a class="el" href="a00315.html">TypeInterface</a> * &gt; &amp;vgv, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00270.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aaa258277993d928c87aed1a62bc8d900">makeTupleSignature</a> (const <a class="el" href="a00270.html">qi::Signature</a> &amp;element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00270.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a03e3b32ae885f36dc89d1f72f91878bd">makeListSignature</a> (const <a class="el" href="a00270.html">qi::Signature</a> &amp;element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00270.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a67377d0f4a7dddc54912d96031b4b06e">makeVarArgsSignature</a> (const <a class="el" href="a00270.html">qi::Signature</a> &amp;element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00270.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a481997bd83b95542e6372d1d94456022">makeKwArgsSignature</a> (const <a class="el" href="a00270.html">qi::Signature</a> &amp;element)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00270.html">qi::Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a0e4e963b37472078c2a9d927b44ef97d">makeMapSignature</a> (const <a class="el" href="a00270.html">qi::Signature</a> &amp;key, const <a class="el" href="a00270.html">qi::Signature</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ac398d2fe06ebe5fdef4da056f35be095">operator!=</a> (const <a class="el" href="a00270.html">Signature</a> &amp;lhs, const <a class="el" href="a00270.html">Signature</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a6df69be73d369666577f9d4b2cd8dd78">operator==</a> (const <a class="el" href="a00270.html">Signature</a> &amp;lhs, const <a class="el" href="a00270.html">Signature</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RF , typename AF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::function&lt; RF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a22ca99743b6c820547dea46057a73ae0">bind</a> (const AF &amp;fun,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00283.html">qi::Translator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ad774296b27b62b0ca406b6d15c4fd170">defaultTranslator</a> (const std::string &amp;name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference on the default <a class="el" href="a00283.html" title="Localization of your source code.">Translator</a>.  <a href="#ad774296b27b62b0ca406b6d15c4fd170"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#af45a0666a72fce61092131ac4318cc90">tr</a> (const std::string &amp;msg, const std::string &amp;domain=&quot;&quot;, const std::string &amp;locale=&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a3f4e89c404bfea877211a60561db4f52">operator==</a> (const <a class="el" href="a00021.html">AnyIterator</a> &amp;a, const <a class="el" href="a00021.html">AnyIterator</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a93f54abf0f63a1de518ebaafbd3b699a">operator!=</a> (const <a class="el" href="a00021.html">AnyIterator</a> &amp;a, const <a class="el" href="a00021.html">AnyIterator</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a6c0458e8f45de0e037c7cb9bfa56b31c">operator&lt;</a> (const <a class="el" href="a00023.html">AnyReference</a> &amp;a, const <a class="el" href="a00023.html">AnyReference</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aa93b0cb5de04863592216daa6888214b">operator==</a> (const <a class="el" href="a00023.html">AnyReference</a> &amp;a, const <a class="el" href="a00023.html">AnyReference</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#aef6d91fe199c228cda7583edf00e5363">operator!=</a> (const <a class="el" href="a00023.html">AnyReference</a> &amp;a, const <a class="el" href="a00023.html">AnyReference</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00023.html">AnyReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a0677f9994ab898cc93a8131b83bd2102">makeGenericTuple</a> (const <a class="el" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a> &amp;values)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00023.html">AnyReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a2f7d98cfcf8874b647ce4fbfbb0040ee">makeGenericTuplePtr</a> (const std::vector&lt; <a class="el" href="a00315.html">TypeInterface</a> * &gt; &amp;types, const std::vector&lt; void * &gt; &amp;values)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ae7ecf9e30b3f2341c824fb4bd5493bbf">operator&lt;</a> (const <a class="el" href="a00024.html">AnyValue</a> &amp;a, const <a class="el" href="a00024.html">AnyValue</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator. Will compare the values within the <a class="el" href="a00024.html">AnyValue</a>.  <a href="#ae7ecf9e30b3f2341c824fb4bd5493bbf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ac9403cd278f0ecd3901d3995f3b713d3">operator==</a> (const <a class="el" href="a00024.html">AnyValue</a> &amp;a, const <a class="el" href="a00024.html">AnyValue</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Value equality operator. Will compare the values within.  <a href="#ac9403cd278f0ecd3901d3995f3b713d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a621564f7183b228b46b58f1569bb563c">operator!=</a> (const <a class="el" href="a00024.html">AnyValue</a> &amp;a, const <a class="el" href="a00024.html">AnyValue</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a41c2015abb2b45d42f54a2558def93e3">asAnyReferenceVector</a> (const <a class="el" href="a00359.html#a9fc9c029f3e47daa5e331a46afca298b">AnyValueVector</a> &amp;vect)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00010.html">qi::Future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a56fc521d5d2aef7f999b479579904cf4">async</a> (T instancePointerOrSharedPointer, const std::string &amp;methodName, <a class="el" href="a00028.html">qi::AutoAnyReference</a> p1=<a class="el" href="a00028.html">qi::AutoAnyReference</a>(), <a class="el" href="a00028.html">qi::AutoAnyReference</a> p2=<a class="el" href="a00028.html">qi::AutoAnyReference</a>(), <a class="el" href="a00028.html">qi::AutoAnyReference</a> p3=<a class="el" href="a00028.html">qi::AutoAnyReference</a>(), <a class="el" href="a00028.html">qi::AutoAnyReference</a> p4=<a class="el" href="a00028.html">qi::AutoAnyReference</a>(), <a class="el" href="a00028.html">qi::AutoAnyReference</a> p5=<a class="el" href="a00028.html">qi::AutoAnyReference</a>(), <a class="el" href="a00028.html">qi::AutoAnyReference</a> p6=<a class="el" href="a00028.html">qi::AutoAnyReference</a>(), <a class="el" href="a00028.html">qi::AutoAnyReference</a> p7=<a class="el" href="a00028.html">qi::AutoAnyReference</a>(), <a class="el" href="a00028.html">qi::AutoAnyReference</a> p8=<a class="el" href="a00028.html">qi::AutoAnyReference</a>())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if&lt; typename <br class="typebreak"/>
<a class="el" href="a00042.html">detail::Accessor</a>&lt; A &gt;<br class="typebreak"/>
::is_accessor, <a class="el" href="a00267.html">SignalBase</a> * &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a167afc34f376286d2e46424ae4941065">signalAccess</a> (A acc, void *instance)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if&lt; typename <br class="typebreak"/>
<a class="el" href="a00042.html">detail::Accessor</a>&lt; A &gt;<br class="typebreak"/>
::is_accessor, <a class="el" href="a00257.html">PropertyBase</a> * &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#aceece21123bf061395fb61c01731a274">propertyAccess</a> (A acc, void *instance)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Proxy , typename Interface &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a32994dde8c5e2313e5a50cb83a87e138">registerProxyInterface</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ProxyType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#acf8a20b9f03fa67591063d18d0d20a7c">registerProxy</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00274.html">StringTypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a23e607036093eb12c791c880d865e5d5">makeTypeEquivalentString</a> (T *, F f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#abe00774a87836a58440771526eb26581">operator&lt;</a> (const <a class="el" href="a00280.html">TraceAnalyzer::FlowLink</a> &amp;a, const <a class="el" href="a00280.html">TraceAnalyzer::FlowLink</a> &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a45c4fec4058dee00453ef20d1c544eec">typeOf</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TypeDispatcher &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">TypeDispatcher &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#aa46c718a20275ea16ae730bd2e2b487a">typeDispatch</a> (const TypeDispatcher &amp;vv, <a class="el" href="a00023.html">AnyReference</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a28374f6240c824f5c32b7d3a30e6ba0c">getType</a> (const std::type_info &amp;type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime Type factory getter. Used by <a class="el" href="a00359.html#a45c4fec4058dee00453ef20d1c544eec">typeOf&lt;T&gt;()</a>  <a href="#a28374f6240c824f5c32b7d3a30e6ba0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a74b3c262e479a240240bf2ddd3cb0f7e">registerType</a> (const std::type_info &amp;typeId, <a class="el" href="a00315.html">TypeInterface</a> *type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime Type factory setter.  <a href="#a74b3c262e479a240240bf2ddd3cb0f7e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#aa42acc117e914a07695eb02cd0a13aeb">typeOf</a> (const T &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type from a value. No need to delete the result.  <a href="#aa42acc117e914a07695eb02cd0a13aeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ae5acba1383706c293755c20935f7d613">registerStruct</a> (<a class="el" href="a00315.html">TypeInterface</a> *type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ad7d0e709c6dd1b32ddd4d9a427926ea5">getRegisteredStruct</a> (const <a class="el" href="a00270.html">qi::Signature</a> &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a04d6828dff16659a53da08c7de30956f">makeDynamicAnyObject</a> (<a class="el" href="a00193.html">DynamicObject</a> *obj, bool destroyObject=true, boost::function&lt; void(<a class="el" href="a00216.html">GenericObject</a> *)&gt; onDelete=boost::function&lt; void(<a class="el" href="a00216.html">GenericObject</a> *)&gt;())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a631fd1daf49d80aa9abb8210efc13769">makeDynamicSharedAnyObjectImpl</a> (<a class="el" href="a00193.html">DynamicObject</a> *obj, boost::shared_ptr&lt; <a class="el" href="a00196.html">Empty</a> &gt; other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a230889c807a35900df1fb6385a926a98">makeDynamicSharedAnyObject</a> (<a class="el" href="a00193.html">DynamicObject</a> *obj, boost::shared_ptr&lt; T &gt; other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00247.html">ObjectTypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#acde1dffa366528f25db3597abb0b2fe5">getDynamicTypeInterface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#afe13c66dd9a2409ff4535a5673f71885">operator&lt;</a> (const <a class="el" href="a00236.html">MetaObject</a> &amp;a, const <a class="el" href="a00236.html">MetaObject</a> &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a6ede9f79bfd42c877ce4c913e1d477b3">makeProxyProperty</a> (<a class="el" href="a00255.html">Property</a>&lt; T &gt; &amp;target, <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a2f3450ea4977e6106d71d1b43fd231ba">makeProxyProperty</a> (<a class="el" href="a00259.html">ProxyProperty</a>&lt; T &gt; &amp;target, <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#ab4ab95a69a97a75ef18b2337ac5a5932">makeProxySignal</a> (<a class="el" href="a00268.html">SignalF</a>&lt; T &gt; &amp;target, <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a748adf53e6743b399564d041658ad6ab">makeProxySignal</a> (<a class="el" href="a00260.html">ProxySignal</a>&lt; T &gt; &amp;target, <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> object, const std::string &amp;signalName)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Dispatcher &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Dispatcher &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#aac32d67b110554995783ad4bd9994229">typeDispatch</a> (const Dispatcher &amp;dispatcher, <a class="el" href="a00023.html">AnyReference</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ad88d038b69d6ddd1416c07784d4c2854">makeTypeOfKind</a> (const <a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83">qi::TypeKind</a> &amp;kind)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ae09c8c0d171c2ef5e3b2c4db795d8db4">makeFloatType</a> (int bytelen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a426b195e4c91c436ffe1a3230ec5f712">makeIntType</a> (bool issigned, int bytelen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a537adf368dd07b2b5d5a248780f4f768">makeVarArgsType</a> (<a class="el" href="a00315.html">TypeInterface</a> *elementType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a4ada86c6a16b6970d55b47851227487f">makeListType</a> (<a class="el" href="a00315.html">TypeInterface</a> *elementType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a84d0f507e9bcd84530c9650100c17a67">makeMapType</a> (<a class="el" href="a00315.html">TypeInterface</a> *keyType, <a class="el" href="a00315.html">TypeInterface</a> *ElementType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00315.html">TypeInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a7eaf3d66d510df1dd23529d3f4f20631">makeTupleType</a> (const std::vector&lt; <a class="el" href="a00315.html">TypeInterface</a> * &gt; &amp;memberTypes, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;elementNames=std::vector&lt; std::string &gt;())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#ae34013b6e2d0244f6863c17607be74a3">operator==</a> (const <a class="el" href="a00326.html">Url</a> &amp;lhs, const <a class="el" href="a00326.html">Url</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a8034f21d05a022058fc33b5d6f544f3c">operator!=</a> (const <a class="el" href="a00326.html">Url</a> &amp;lhs, const <a class="el" href="a00326.html">Url</a> &amp;rhs)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a74acfd43dea835f6752dad8fa47cc7f1">sleepFor</a> (const <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">qi::Duration</a> &amp;d)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a342cbb877923284a84ec54f51a4009c4">sleepFor</a> (const boost::chrono::duration&lt; Rep, Period &gt; &amp;d)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00359.html#a25f5e223a90ec2016534ef6d33d9729f">sleepUntil</a> (const <a class="el" href="a00359.html#ab752bd54724652b6a0b86bd680b434de">SteadyClockTimePoint</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the execution of the current thread until <code>t</code> has been reached.  <a href="#a25f5e223a90ec2016534ef6d33d9729f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#a58586cd571c328f307c91f3768d47ed5">sleepUntil</a> (const boost::chrono::time_point&lt; <a class="el" href="a00271.html">SteadyClock</a>, <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">Duration</a> &gt; &amp;t)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00359.html#adf1f0ef331bcf3d99b238e94b17a59ea">sleepUntil</a> (const boost::chrono::time_point&lt; <a class="el" href="a00332.html">WallClock</a>, <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">Duration</a> &gt; &amp;t)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Language factory, for each language (C++, Python, ...) a factory should be registered. The factory will be used to load the module </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a9a26927d76f789c14adedacf26533218"></a><!-- doxytag: member="qi::AnyAutoService" ref="a9a26927d76f789c14adedacf26533218" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00029.html">AutoService</a>&lt;<a class="el" href="a00196.html">qi::Empty</a>&gt; <a class="el" href="a00359.html#a9a26927d76f789c14adedacf26533218">qi::AnyAutoService</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00371_source.html#l00105">105</a> of file <a class="el" href="a00371_source.html">autoservice.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e60a9cbccf0a2138b4f838b9ccd356a"></a><!-- doxytag: member="qi::AnyObject" ref="a0e60a9cbccf0a2138b4f838b9ccd356a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00015.html">Object</a>&lt; <a class="el" href="a00196.html">Empty</a> &gt; <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">qi::AnyObject</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00337_source.html#l00021">21</a> of file <a class="el" href="a00337_source.html">anyobject.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6526717e2ad65d93d8a801c099cc90a"></a><!-- doxytag: member="qi::AnyReferenceVector" ref="af6526717e2ad65d93d8a801c099cc90a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="a00023.html">AnyReference</a> &gt; <a class="el" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">qi::AnyReferenceVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00400_source.html#l00023">23</a> of file <a class="el" href="a00400_source.html">anyreference.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc9c029f3e47daa5e331a46afca298b"></a><!-- doxytag: member="qi::AnyValueVector" ref="a9fc9c029f3e47daa5e331a46afca298b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="a00024.html">AnyValue</a> &gt; <a class="el" href="a00359.html#a9fc9c029f3e47daa5e331a46afca298b">qi::AnyValueVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00339_source.html#l00109">109</a> of file <a class="el" href="a00339_source.html">anyvalue.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2ed3fa7ace03e256bedcccb7eda2917"></a><!-- doxytag: member="qi::AnyVarArguments" ref="ac2ed3fa7ace03e256bedcccb7eda2917" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00329.html">VarArguments</a> <a class="el" href="a00359.html#ac2ed3fa7ace03e256bedcccb7eda2917">qi::AnyVarArguments</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00335_source.html#l00050">50</a> of file <a class="el" href="a00335_source.html">anyfunction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a984d5fa8d8f50699c31a3da9bca5b63a"></a><!-- doxytag: member="qi::AnyWeakObject" ref="a984d5fa8d8f50699c31a3da9bca5b63a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00333.html">WeakObject</a>&lt; <a class="el" href="a00196.html">Empty</a> &gt; <a class="el" href="a00359.html#a984d5fa8d8f50699c31a3da9bca5b63a">qi::AnyWeakObject</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00415_source.html#l00308">308</a> of file <a class="el" href="a00415_source.html">object.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a684b8e9b61abeca94f79afd1fa961794"></a><!-- doxytag: member="qi::ApplicationSessionOptions" ref="a684b8e9b61abeca94f79afd1fa961794" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00359.html#aba08c16e9fd5810e6475a0c8e1dfa3c3">qi::uint32_t</a> <a class="el" href="a00359.html#a684b8e9b61abeca94f79afd1fa961794">qi::ApplicationSessionOptions</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00342_source.html#l00016">16</a> of file <a class="el" href="a00342_source.html">applicationsession.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a61807322c399d9d4c3483626e7b58bfe"></a><!-- doxytag: member="qi::CapabilityMap" ref="a61807322c399d9d4c3483626e7b58bfe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="a00024.html">AnyValue</a>&gt; <a class="el" href="a00359.html#a61807322c399d9d4c3483626e7b58bfe">qi::CapabilityMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00344_source.html#l00036">36</a> of file <a class="el" href="a00344_source.html">binarycodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad285b93d0b3fd990de2df5bb7ea893bd"></a><!-- doxytag: member="qi::codecvt_type" ref="ad285b93d0b3fd990de2df5bb7ea893bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; <a class="el" href="a00359.html#ad285b93d0b3fd990de2df5bb7ea893bd">qi::codecvt_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Standard std::codecvt type accepted by STL and boost. </p>
<p>Typedef for std::codecvt&lt;wchar_t, char, std::mbstate_t&gt; that can be used with boost::filesystem::path and std::locale. </p>

<p>Definition at line <a class="el" href="a00376_source.html#l00416">416</a> of file <a class="el" href="a00376_source.html">path.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac26bb2a65903f833b31e13a1eb4736f6"></a><!-- doxytag: member="qi::DeserializeObjectCallback" ref="ac26bb2a65903f833b31e13a1eb4736f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;<a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> (const <a class="el" href="a00244.html">ObjectSerializationInfo</a>&amp;)&gt; <a class="el" href="a00359.html#ac26bb2a65903f833b31e13a1eb4736f6">qi::DeserializeObjectCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of callback invoked by sdeerializer when it encounters an object. </p>

<p>Definition at line <a class="el" href="a00344_source.html#l00110">110</a> of file <a class="el" href="a00344_source.html">binarycodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5d4c066f262dfde002d18537d30260e"></a><!-- doxytag: member="qi::Duration" ref="aa5d4c066f262dfde002d18537d30260e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::chrono::duration&lt;<a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::nano&gt; <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">qi::Duration</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience typedefs. </p>

<p>Definition at line <a class="el" href="a00346_source.html#l00018">18</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa61ce87899c4efa29126c580a4ee808f"></a><!-- doxytag: member="qi::DynamicFunction" ref="aa61ce87899c4efa29126c580a4ee808f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;<a class="el" href="a00023.html">AnyReference</a>(const <a class="el" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a>&amp;)&gt; <a class="el" href="a00359.html#aa61ce87899c4efa29126c580a4ee808f">qi::DynamicFunction</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00335_source.html#l00142">142</a> of file <a class="el" href="a00335_source.html">anyfunction.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a22d0bee7d7642c80bcef42ed0b734945"></a><!-- doxytag: member="qi::Hours" ref="a22d0bee7d7642c80bcef42ed0b734945" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::chrono::duration&lt;<a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::ratio&lt;3600&gt; &gt; <a class="el" href="a00359.html#a22d0bee7d7642c80bcef42ed0b734945">qi::Hours</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00346_source.html#l00024">24</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7166635ba92d23bff55b96338775dcb"></a><!-- doxytag: member="qi::int16_t" ref="ad7166635ba92d23bff55b96338775dcb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#ad7166635ba92d23bff55b96338775dcb">qi::int16_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform signed integer of length 16 bits (2 bytes). </p>

<p>Definition at line <a class="el" href="a00442_source.html#l00074">74</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ed30d0c39356a44feabae5054779c42"></a><!-- doxytag: member="qi::int32_t" ref="a2ed30d0c39356a44feabae5054779c42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a2ed30d0c39356a44feabae5054779c42">qi::int32_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform signed integer of length 32 bits (4 bytes). </p>

<p>Definition at line <a class="el" href="a00442_source.html#l00075">75</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d"></a><!-- doxytag: member="qi::int64_t" ref="a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">qi::int64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform signed integer of length 64 bits (8 bytes). </p>

<p>Definition at line <a class="el" href="a00442_source.html#l00076">76</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80fe74541b93ef969ff854a4e2e567e1"></a><!-- doxytag: member="qi::int8_t" ref="a80fe74541b93ef969ff854a4e2e567e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a80fe74541b93ef969ff854a4e2e567e1">qi::int8_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform signed integer of length 8 bits (1 byte). </p>
 
<p>Definition at line <a class="el" href="a00442_source.html#l00073">73</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96c761b741f387d89021e8a3d96a7506"></a><!-- doxytag: member="qi::LogContext" ref="a96c761b741f387d89021e8a3d96a7506" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="a00359.html#a96c761b741f387d89021e8a3d96a7506">qi::LogContext</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Logs context attribute value. </p>

<p>Definition at line <a class="el" href="a00364_source.html#l00170">170</a> of file <a class="el" href="a00364_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ed86b325a1733ad7dca7f94f60b80c7"></a><!-- doxytag: member="qi::MetaMethodParameterVector" ref="a5ed86b325a1733ad7dca7f94f60b80c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="a00235.html">MetaMethodParameter</a>&gt; <a class="el" href="a00359.html#a5ed86b325a1733ad7dca7f94f60b80c7">qi::MetaMethodParameterVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00433_source.html#l00038">38</a> of file <a class="el" href="a00433_source.html">metamethod.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba135b1052ec59022ce6a7bdbd6268c1"></a><!-- doxytag: member="qi::MicroSeconds" ref="aba135b1052ec59022ce6a7bdbd6268c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::chrono::duration&lt;<a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::micro&gt; <a class="el" href="a00359.html#aba135b1052ec59022ce6a7bdbd6268c1">qi::MicroSeconds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00346_source.html#l00020">20</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65b3b7288a6892c01caae62907d31c62"></a><!-- doxytag: member="qi::MilliSeconds" ref="a65b3b7288a6892c01caae62907d31c62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::chrono::duration&lt;<a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::milli&gt; <a class="el" href="a00359.html#a65b3b7288a6892c01caae62907d31c62">qi::MilliSeconds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00346_source.html#l00021">21</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5014ba6f659bada6e21717ea77c0a73d"></a><!-- doxytag: member="qi::Minutes" ref="a5014ba6f659bada6e21717ea77c0a73d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::chrono::duration&lt;<a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::ratio&lt;60&gt; &gt; <a class="el" href="a00359.html#a5014ba6f659bada6e21717ea77c0a73d">qi::Minutes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00346_source.html#l00023">23</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afdd4334b0f48a51c9a138024efc8f19c"></a><!-- doxytag: member="qi::ModuleFactoryFunctor" ref="afdd4334b0f48a51c9a138024efc8f19c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;<a class="el" href="a00022.html">AnyModule</a> (const <a class="el" href="a00243.html">qi::ModuleInfo</a>&amp;)&gt; <a class="el" href="a00359.html#afdd4334b0f48a51c9a138024efc8f19c">qi::ModuleFactoryFunctor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00336_source.html#l00146">146</a> of file <a class="el" href="a00336_source.html">anymodule.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a037ade806630690498a71c88f48611a0"></a><!-- doxytag: member="qi::NanoSeconds" ref="a037ade806630690498a71c88f48611a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::chrono::duration&lt;<a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>, boost::nano&gt; <a class="el" href="a00359.html#a037ade806630690498a71c88f48611a0">qi::NanoSeconds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00346_source.html#l00019">19</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b5a1cd8421b582197e3819ac1f12f6f"></a><!-- doxytag: member="qi::ObjectStatistics" ref="a8b5a1cd8421b582197e3819ac1f12f6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;unsigned int, <a class="el" href="a00240.html">MethodStatistics</a>&gt; <a class="el" href="a00359.html#a8b5a1cd8421b582197e3819ac1f12f6f">qi::ObjectStatistics</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00413_source.html#l00089">89</a> of file <a class="el" href="a00413_source.html">manageable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3f0d036edc4edebd2bf5cb09eaf99d9"></a><!-- doxytag: member="qi::PathVector" ref="ad3f0d036edc4edebd2bf5cb09eaf99d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="a00250.html">Path</a>&gt; <a class="el" href="a00359.html#ad3f0d036edc4edebd2bf5cb09eaf99d9">qi::PathVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00376_source.html#l00022">22</a> of file <a class="el" href="a00376_source.html">path.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a463a99b0e8740a136d135f3c305f892e"></a><!-- doxytag: member="qi::Seconds" ref="a463a99b0e8740a136d135f3c305f892e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::chrono::duration&lt;<a class="el" href="a00359.html#a2dfd5c2c2c0d90a0f7a0fbb6b8ab0c0d">int64_t</a>&gt; <a class="el" href="a00359.html#a463a99b0e8740a136d135f3c305f892e">qi::Seconds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00346_source.html#l00022">22</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5875da1c0d54d3fa979c19ccb88253fa"></a><!-- doxytag: member="qi::SerializeObjectCallback" ref="a5875da1c0d54d3fa979c19ccb88253fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;<a class="el" href="a00244.html">ObjectSerializationInfo</a> (const <a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a>&amp;)&gt; <a class="el" href="a00359.html#a5875da1c0d54d3fa979c19ccb88253fa">qi::SerializeObjectCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type of callback invoked by serializer when it encounters an object. </p>

<p>Definition at line <a class="el" href="a00344_source.html#l00113">113</a> of file <a class="el" href="a00344_source.html">binarycodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30c4304ccd890650e355902dd160d180"></a><!-- doxytag: member="qi::ServiceInfoVector" ref="a30c4304ccd890650e355902dd160d180" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="a00264.html">qi::ServiceInfo</a>&gt; <a class="el" href="a00359.html#a30c4304ccd890650e355902dd160d180">qi::ServiceInfoVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00374_source.html#l00050">50</a> of file <a class="el" href="a00374_source.html">serviceinfo.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f87eaf6b8d541402a41d14a8b33816"></a><!-- doxytag: member="qi::SessionPtr" ref="ae3f87eaf6b8d541402a41d14a8b33816" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="a00265.html">Session</a>&gt; <a class="el" href="a00359.html#ae3f87eaf6b8d541402a41d14a8b33816">qi::SessionPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00388_source.html#l00112">112</a> of file <a class="el" href="a00388_source.html">session.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69247b0b30dc5f6df95488f18e9aff01"></a><!-- doxytag: member="qi::SignalLink" ref="a69247b0b30dc5f6df95488f18e9aff01" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00359.html#a2ee81d854cc30ed5de683db744436323">qi::uint64_t</a> <a class="el" href="a00359.html#a69247b0b30dc5f6df95488f18e9aff01">qi::SignalLink</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00389_source.html#l00033">33</a> of file <a class="el" href="a00389_source.html">signal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d3f787f311e8225a14aa23d0050a396"></a><!-- doxytag: member="qi::SignalSubscriberPtr" ref="a3d3f787f311e8225a14aa23d0050a396" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="a00269.html">SignalSubscriber</a>&gt; <a class="el" href="a00359.html#a3d3f787f311e8225a14aa23d0050a396">qi::SignalSubscriberPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00389_source.html#l00296">296</a> of file <a class="el" href="a00389_source.html">signal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa71087a4ad8ea509d34fb98bb1c9e2dd"></a><!-- doxytag: member="qi::SignatureVector" ref="aa71087a4ad8ea509d34fb98bb1c9e2dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="a00270.html">Signature</a>&gt; <a class="el" href="a00359.html#aa71087a4ad8ea509d34fb98bb1c9e2dd">qi::SignatureVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00390_source.html#l00062">62</a> of file <a class="el" href="a00390_source.html">signature.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab752bd54724652b6a0b86bd680b434de"></a><!-- doxytag: member="qi::SteadyClockTimePoint" ref="ab752bd54724652b6a0b86bd680b434de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00271.html#a8bb7553fd66a3301bafa2fb9fd3fce14">SteadyClock::SteadyClockTimePoint</a> <a class="el" href="a00359.html#ab752bd54724652b6a0b86bd680b434de">qi::SteadyClockTimePoint</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Steady clock time point. </p>

<p>Definition at line <a class="el" href="a00346_source.html#l00160">160</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7b1d8a9d9dfe41eaf074e2428c13e4b"></a><!-- doxytag: member="qi::uint16_t" ref="ac7b1d8a9d9dfe41eaf074e2428c13e4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#ac7b1d8a9d9dfe41eaf074e2428c13e4b">qi::uint16_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform unsigned integer of length 16 bits (2 bytes). </p>

<p>Definition at line <a class="el" href="a00442_source.html#l00079">79</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba08c16e9fd5810e6475a0c8e1dfa3c3"></a><!-- doxytag: member="qi::uint32_t" ref="aba08c16e9fd5810e6475a0c8e1dfa3c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#aba08c16e9fd5810e6475a0c8e1dfa3c3">qi::uint32_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform unsigned integer of length 32 bits (4 bytes). </p>

<p>Definition at line <a class="el" href="a00442_source.html#l00080">80</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ee81d854cc30ed5de683db744436323"></a><!-- doxytag: member="qi::uint64_t" ref="a2ee81d854cc30ed5de683db744436323" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a2ee81d854cc30ed5de683db744436323">qi::uint64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform unsigned integer of length 64 bits (8 bytes). </p>

<p>Definition at line <a class="el" href="a00442_source.html#l00081">81</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1c41798686ce92a711a18be804316988"></a><!-- doxytag: member="qi::uint8_t" ref="a1c41798686ce92a711a18be804316988" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a1c41798686ce92a711a18be804316988">qi::uint8_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cross-platform unsigned integer of length 8 bits (1 byte). </p>

<p>Definition at line <a class="el" href="a00442_source.html#l00078">78</a> of file <a class="el" href="a00442_source.html">types.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60eaea69ef2b87575875e6e82fd6d60f"></a><!-- doxytag: member="qi::UrlVector" ref="a60eaea69ef2b87575875e6e82fd6d60f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="a00326.html">Url</a>&gt; <a class="el" href="a00359.html#a60eaea69ef2b87575875e6e82fd6d60f">qi::UrlVector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00443_source.html#l00133">133</a> of file <a class="el" href="a00443_source.html">url.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a739c9431170590d38d2bde9cf595d474"></a><!-- doxytag: member="qi::WallClockTimePoint" ref="a739c9431170590d38d2bde9cf595d474" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00332.html#a63b19738a9e6d9e69090d8792e4b30c5">WallClock::WallClockTimePoint</a> <a class="el" href="a00359.html#a739c9431170590d38d2bde9cf595d474">qi::WallClockTimePoint</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wall clock time point. </p>

<p>Definition at line <a class="el" href="a00346_source.html#l00161">161</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a66922f30da6f5708915f47ed330e0de0"></a><!-- doxytag: member="qi::FutureCallbackType" ref="a66922f30da6f5708915f47ed330e0de0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#a66922f30da6f5708915f47ed330e0de0">qi::FutureCallbackType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a66922f30da6f5708915f47ed330e0de0a994de07b744ad919d45ec8666da03c4f"></a><!-- doxytag: member="FutureCallbackType_Sync" ref="a66922f30da6f5708915f47ed330e0de0a994de07b744ad919d45ec8666da03c4f" args="" -->FutureCallbackType_Sync</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a66922f30da6f5708915f47ed330e0de0adee2428ef5a90f515ac7737c9a159d75"></a><!-- doxytag: member="FutureCallbackType_Async" ref="a66922f30da6f5708915f47ed330e0de0adee2428ef5a90f515ac7737c9a159d75" args="" -->FutureCallbackType_Async</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00352_source.html#l00076">76</a> of file <a class="el" href="a00352_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51"></a><!-- doxytag: member="qi::FutureState" ref="a06fde6361c5d179ff0b9615a0ac4aa51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#a06fde6361c5d179ff0b9615a0ac4aa51">qi::FutureState</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>State of the future. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51a7353b65c14fc6205a79798a3fbd4401a"></a><!-- doxytag: member="FutureState_None" ref="a06fde6361c5d179ff0b9615a0ac4aa51a7353b65c14fc6205a79798a3fbd4401a" args="" -->FutureState_None</em>&nbsp;</td><td>
<p><a class="el" href="a00010.html">Future</a> is not tied to a promise. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51ab4aa09c0a00d9b24933df2952b28bc15"></a><!-- doxytag: member="FutureState_Running" ref="a06fde6361c5d179ff0b9615a0ac4aa51ab4aa09c0a00d9b24933df2952b28bc15" args="" -->FutureState_Running</em>&nbsp;</td><td>
<p>Operation pending. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51a3c3a4f9e8d394891d5717e8e962ce8f9"></a><!-- doxytag: member="FutureState_Canceled" ref="a06fde6361c5d179ff0b9615a0ac4aa51a3c3a4f9e8d394891d5717e8e962ce8f9" args="" -->FutureState_Canceled</em>&nbsp;</td><td>
<p>The future has been canceled. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51a8a7110a297926cba1ba38f5272a1ba5d"></a><!-- doxytag: member="FutureState_FinishedWithError" ref="a06fde6361c5d179ff0b9615a0ac4aa51a8a7110a297926cba1ba38f5272a1ba5d" args="" -->FutureState_FinishedWithError</em>&nbsp;</td><td>
<p>The operation is finished with an error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a06fde6361c5d179ff0b9615a0ac4aa51aa34f218f2ec9a05027f11f7e524cef0b"></a><!-- doxytag: member="FutureState_FinishedWithValue" ref="a06fde6361c5d179ff0b9615a0ac4aa51aa34f218f2ec9a05027f11f7e524cef0b" args="" -->FutureState_FinishedWithValue</em>&nbsp;</td><td>
<p>The operation is finished with a value. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00352_source.html#l00068">68</a> of file <a class="el" href="a00352_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad1f54e93f8719f4708669496c8a20a9c"></a><!-- doxytag: member="qi::FutureTimeout" ref="ad1f54e93f8719f4708669496c8a20a9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#ad1f54e93f8719f4708669496c8a20a9c">qi::FutureTimeout</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad1f54e93f8719f4708669496c8a20a9ca648162635a9fcbc69da607a51197e07c"></a><!-- doxytag: member="FutureTimeout_Infinite" ref="ad1f54e93f8719f4708669496c8a20a9ca648162635a9fcbc69da607a51197e07c" args="" -->FutureTimeout_Infinite</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad1f54e93f8719f4708669496c8a20a9caa418e4954620069c7ddbb4bc6c1e661d"></a><!-- doxytag: member="FutureTimeout_None" ref="ad1f54e93f8719f4708669496c8a20a9caa418e4954620069c7ddbb4bc6c1e661d" args="" -->FutureTimeout_None</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00352_source.html#l00081">81</a> of file <a class="el" href="a00352_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396b"></a><!-- doxytag: member="qi::LogColor" ref="aa1d7c0b8007b1ab09fc2de493108396b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#aa1d7c0b8007b1ab09fc2de493108396b">qi::LogColor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Logs color mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396ba3bd8da8f7b698c20476796110d4647a1"></a><!-- doxytag: member="LogColor_Never" ref="aa1d7c0b8007b1ab09fc2de493108396ba3bd8da8f7b698c20476796110d4647a1" args="" -->LogColor_Never</em>&nbsp;</td><td>
<p>Never show color. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396ba6057d0099587041711b20c47580e79b0"></a><!-- doxytag: member="LogColor_Auto" ref="aa1d7c0b8007b1ab09fc2de493108396ba6057d0099587041711b20c47580e79b0" args="" -->LogColor_Auto</em>&nbsp;</td><td>
<p>Auto color. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa1d7c0b8007b1ab09fc2de493108396ba691067550d59a0e744b04b4bb782e829"></a><!-- doxytag: member="LogColor_Always" ref="aa1d7c0b8007b1ab09fc2de493108396ba691067550d59a0e744b04b4bb782e829" args="" -->LogColor_Always</em>&nbsp;</td><td>
<p>Always show color. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00364_source.html#l00146">146</a> of file <a class="el" href="a00364_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88"></a><!-- doxytag: member="qi::LogContextAttr" ref="aeb49003e94f0efc86109a278d8d55f88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#aeb49003e94f0efc86109a278d8d55f88">qi::LogContextAttr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Logs context attribute. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a7de8d9712806cce940066df9c298dde6"></a><!-- doxytag: member="LogContextAttr_None" ref="aeb49003e94f0efc86109a278d8d55f88a7de8d9712806cce940066df9c298dde6" args="" -->LogContextAttr_None</em>&nbsp;</td><td>
<p>No context. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88aa98c7a6e68d61670619e925a6030850a"></a><!-- doxytag: member="LogContextAttr_Verbosity" ref="aeb49003e94f0efc86109a278d8d55f88aa98c7a6e68d61670619e925a6030850a" args="" -->LogContextAttr_Verbosity</em>&nbsp;</td><td>
<p>Show logs level. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a5082e95ca9152e6dd0c45acccef85dea"></a><!-- doxytag: member="LogContextAttr_ShortVerbosity" ref="aeb49003e94f0efc86109a278d8d55f88a5082e95ca9152e6dd0c45acccef85dea" args="" -->LogContextAttr_ShortVerbosity</em>&nbsp;</td><td>
<p>Show short logs level. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88abe8c8facb4ddf7e7cf8e362db8101e53"></a><!-- doxytag: member="LogContextAttr_Date" ref="aeb49003e94f0efc86109a278d8d55f88abe8c8facb4ddf7e7cf8e362db8101e53" args="" -->LogContextAttr_Date</em>&nbsp;</td><td>
<p>Show dates. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a7dd9f2a728db294bbccab4452d97a718"></a><!-- doxytag: member="LogContextAttr_Tid" ref="aeb49003e94f0efc86109a278d8d55f88a7dd9f2a728db294bbccab4452d97a718" args="" -->LogContextAttr_Tid</em>&nbsp;</td><td>
<p>Show threads id. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88ace5552c93742d5968ed2e9551317c06b"></a><!-- doxytag: member="LogContextAttr_Category" ref="aeb49003e94f0efc86109a278d8d55f88ace5552c93742d5968ed2e9551317c06b" args="" -->LogContextAttr_Category</em>&nbsp;</td><td>
<p>Show categories. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88a8b875514dd1c415afa9d92c9ca2a8e76"></a><!-- doxytag: member="LogContextAttr_File" ref="aeb49003e94f0efc86109a278d8d55f88a8b875514dd1c415afa9d92c9ca2a8e76" args="" -->LogContextAttr_File</em>&nbsp;</td><td>
<p>Show logs files. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88add0679d327681fecef744811c7a3fdbf"></a><!-- doxytag: member="LogContextAttr_Function" ref="aeb49003e94f0efc86109a278d8d55f88add0679d327681fecef744811c7a3fdbf" args="" -->LogContextAttr_Function</em>&nbsp;</td><td>
<p>Show functions name. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aeb49003e94f0efc86109a278d8d55f88ab137c7cf28a44e366b6d2e6ec675587f"></a><!-- doxytag: member="LogContextAttr_Return" ref="aeb49003e94f0efc86109a278d8d55f88ab137c7cf28a44e366b6d2e6ec675587f" args="" -->LogContextAttr_Return</em>&nbsp;</td><td>
<p>Print an end line between contexts and logs. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00364_source.html#l00155">155</a> of file <a class="el" href="a00364_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5"></a><!-- doxytag: member="qi::LogLevel" ref="ae404a3651bdc9116349a4a60a1d0afc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#ae404a3651bdc9116349a4a60a1d0afc5">qi::LogLevel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Log level verbosity. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a77059e55763f4584259218f0802d6b58"></a><!-- doxytag: member="LogLevel_Silent" ref="ae404a3651bdc9116349a4a60a1d0afc5a77059e55763f4584259218f0802d6b58" args="" -->LogLevel_Silent</em>&nbsp;</td><td>
<p>silent log level </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5ab7f68198dd8bff433614815c8a226fc8"></a><!-- doxytag: member="LogLevel_Fatal" ref="ae404a3651bdc9116349a4a60a1d0afc5ab7f68198dd8bff433614815c8a226fc8" args="" -->LogLevel_Fatal</em>&nbsp;</td><td>
<p>fatal log level </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a29568c44b55d44dec768128135f45d4a"></a><!-- doxytag: member="LogLevel_Error" ref="ae404a3651bdc9116349a4a60a1d0afc5a29568c44b55d44dec768128135f45d4a" args="" -->LogLevel_Error</em>&nbsp;</td><td>
<p>error log level </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a1f5fad47e4e5cef1a8d437f94b9cc56f"></a><!-- doxytag: member="LogLevel_Warning" ref="ae404a3651bdc9116349a4a60a1d0afc5a1f5fad47e4e5cef1a8d437f94b9cc56f" args="" -->LogLevel_Warning</em>&nbsp;</td><td>
<p>warning log level </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5ab813d452a834cc8990cde0a8592c9f8d"></a><!-- doxytag: member="LogLevel_Info" ref="ae404a3651bdc9116349a4a60a1d0afc5ab813d452a834cc8990cde0a8592c9f8d" args="" -->LogLevel_Info</em>&nbsp;</td><td>
<p>info log level </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a990d6cb9c4c1d0557c2e3780ae345839"></a><!-- doxytag: member="LogLevel_Verbose" ref="ae404a3651bdc9116349a4a60a1d0afc5a990d6cb9c4c1d0557c2e3780ae345839" args="" -->LogLevel_Verbose</em>&nbsp;</td><td>
<p>verbose log level </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae404a3651bdc9116349a4a60a1d0afc5a030864da44cde81392a2e2fbd2f33b1e"></a><!-- doxytag: member="LogLevel_Debug" ref="ae404a3651bdc9116349a4a60a1d0afc5a030864da44cde81392a2e2fbd2f33b1e" args="" -->LogLevel_Debug</em>&nbsp;</td><td>
<p>debug log level </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00364_source.html#l00133">133</a> of file <a class="el" href="a00364_source.html">log.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af26fc7fa51e2905573cda6a194af6cae"></a><!-- doxytag: member="qi::MetaCallType" ref="af26fc7fa51e2905573cda6a194af6cae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#af26fc7fa51e2905573cda6a194af6cae">qi::MetaCallType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Specifies how a call should be made. Can be used at both call-site, and callback-registration site. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af26fc7fa51e2905573cda6a194af6caea0427d0d572be1d1929de10cb006946e8"></a><!-- doxytag: member="MetaCallType_Auto" ref="af26fc7fa51e2905573cda6a194af6caea0427d0d572be1d1929de10cb006946e8" args="" -->MetaCallType_Auto</em>&nbsp;</td><td>
<p>Honor the default behavior. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af26fc7fa51e2905573cda6a194af6caea90daab2e41b08efb5341e827e543ebbc"></a><!-- doxytag: member="MetaCallType_Direct" ref="af26fc7fa51e2905573cda6a194af6caea90daab2e41b08efb5341e827e543ebbc" args="" -->MetaCallType_Direct</em>&nbsp;</td><td>
<p>Force a synchronous call. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af26fc7fa51e2905573cda6a194af6caea44b53fab14f133a377cfa684c4921b08"></a><!-- doxytag: member="MetaCallType_Queued" ref="af26fc7fa51e2905573cda6a194af6caea44b53fab14f133a377cfa684c4921b08" args="" -->MetaCallType_Queued</em>&nbsp;</td><td>
<p>Force an asynchronous call in an other thread. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00441_source.html#l00019">19</a> of file <a class="el" href="a00441_source.html">typeobject.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227"></a><!-- doxytag: member="qi::ObjectThreadingModel" ref="a8d59aed9fc0a2b4ee91991e2888d0227" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#a8d59aed9fc0a2b4ee91991e2888d0227">qi::ObjectThreadingModel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Possible thread models for an object. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227a56239778f0c7fc1f4ab6207862e81fbc"></a><!-- doxytag: member="ObjectThreadingModel_SingleThread" ref="a8d59aed9fc0a2b4ee91991e2888d0227a56239778f0c7fc1f4ab6207862e81fbc" args="" -->ObjectThreadingModel_SingleThread</em>&nbsp;</td><td>
<p><a class="el" href="a00015.html">Object</a> is not thread safe, all method calls must occur in the same thread. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227a6551c85d1e42bb6cff437d35ee1661cc"></a><!-- doxytag: member="ObjectThreadingModel_MultiThread" ref="a8d59aed9fc0a2b4ee91991e2888d0227a6551c85d1e42bb6cff437d35ee1661cc" args="" -->ObjectThreadingModel_MultiThread</em>&nbsp;</td><td>
<p><a class="el" href="a00015.html">Object</a> is thread safe, multiple calls can occur in different threads in parallel. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8d59aed9fc0a2b4ee91991e2888d0227a4b1933f8429b66806e8387c1aff33cfd"></a><!-- doxytag: member="ObjectThreadingModel_Default" ref="a8d59aed9fc0a2b4ee91991e2888d0227a4b1933f8429b66806e8387c1aff33cfd" args="" -->ObjectThreadingModel_Default</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00413_source.html#l00030">30</a> of file <a class="el" href="a00413_source.html">manageable.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321"></a><!-- doxytag: member="qi::StreamColor" ref="a118f2d350ecce997af3f9e1c817fa321" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#a118f2d350ecce997af3f9e1c817fa321">qi::StreamColor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Stream Color enum. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Only working under POSIX.  </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a344631221068a24cef3301551065bc00"></a><!-- doxytag: member="StreamColor_None" ref="a118f2d350ecce997af3f9e1c817fa321a344631221068a24cef3301551065bc00" args="" -->StreamColor_None</em>&nbsp;</td><td>
<p>No Color. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321aa5ae1a9eb8c9ca2c0427682808b5b3a8"></a><!-- doxytag: member="StreamColor_Reset" ref="a118f2d350ecce997af3f9e1c817fa321aa5ae1a9eb8c9ca2c0427682808b5b3a8" args="" -->StreamColor_Reset</em>&nbsp;</td><td>
<p>Reset the color and mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a4f2f77f9392a206c386c1e89422e3152"></a><!-- doxytag: member="StreamColor_Bold" ref="a118f2d350ecce997af3f9e1c817fa321a4f2f77f9392a206c386c1e89422e3152" args="" -->StreamColor_Bold</em>&nbsp;</td><td>
<p>Bold mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321aac8b681a7977a3d0a07ffcee0b99d5af"></a><!-- doxytag: member="StreamColor_Faint" ref="a118f2d350ecce997af3f9e1c817fa321aac8b681a7977a3d0a07ffcee0b99d5af" args="" -->StreamColor_Faint</em>&nbsp;</td><td>
<p>Faint mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a67fec5cb524c9c012d15a814833b1e57"></a><!-- doxytag: member="StreamColor_Standout" ref="a118f2d350ecce997af3f9e1c817fa321a67fec5cb524c9c012d15a814833b1e57" args="" -->StreamColor_Standout</em>&nbsp;</td><td>
<p>Standout mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a4715eae0b58f7aa8cb08adfa6b5788b9"></a><!-- doxytag: member="StreamColor_Underline" ref="a118f2d350ecce997af3f9e1c817fa321a4715eae0b58f7aa8cb08adfa6b5788b9" args="" -->StreamColor_Underline</em>&nbsp;</td><td>
<p>Underline mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a9f4660fb42a98a264060e46d5ba396b8"></a><!-- doxytag: member="StreamColor_Blink" ref="a118f2d350ecce997af3f9e1c817fa321a9f4660fb42a98a264060e46d5ba396b8" args="" -->StreamColor_Blink</em>&nbsp;</td><td>
<p>Blink mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321ab5ad1ee5aa153c51cb41d78ba91632a1"></a><!-- doxytag: member="StreamColor_Overline" ref="a118f2d350ecce997af3f9e1c817fa321ab5ad1ee5aa153c51cb41d78ba91632a1" args="" -->StreamColor_Overline</em>&nbsp;</td><td>
<p>Overline mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a43a4c4c728f3f852cdb6e454ef918824"></a><!-- doxytag: member="StreamColor_Black" ref="a118f2d350ecce997af3f9e1c817fa321a43a4c4c728f3f852cdb6e454ef918824" args="" -->StreamColor_Black</em>&nbsp;</td><td>
<p>Black. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a67c34ed466def0e9a5dbf1da90fedde0"></a><!-- doxytag: member="StreamColor_DarkRed" ref="a118f2d350ecce997af3f9e1c817fa321a67c34ed466def0e9a5dbf1da90fedde0" args="" -->StreamColor_DarkRed</em>&nbsp;</td><td>
<p>Dark Red. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a16f2e3b9e225ef941f0fe8b5a8a6f79c"></a><!-- doxytag: member="StreamColor_DarkGreen" ref="a118f2d350ecce997af3f9e1c817fa321a16f2e3b9e225ef941f0fe8b5a8a6f79c" args="" -->StreamColor_DarkGreen</em>&nbsp;</td><td>
<p>Dark Green. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a68b0b8fdcb78a4b2f8bd9eabf244efaa"></a><!-- doxytag: member="StreamColor_Brown" ref="a118f2d350ecce997af3f9e1c817fa321a68b0b8fdcb78a4b2f8bd9eabf244efaa" args="" -->StreamColor_Brown</em>&nbsp;</td><td>
<p>Brown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a1c64bda3e21fa88c070db2ac2bcd6bd5"></a><!-- doxytag: member="StreamColor_DarkBlue" ref="a118f2d350ecce997af3f9e1c817fa321a1c64bda3e21fa88c070db2ac2bcd6bd5" args="" -->StreamColor_DarkBlue</em>&nbsp;</td><td>
<p>Dark Blue. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321af937c4634377d7684ecbe385807e6c37"></a><!-- doxytag: member="StreamColor_Purple" ref="a118f2d350ecce997af3f9e1c817fa321af937c4634377d7684ecbe385807e6c37" args="" -->StreamColor_Purple</em>&nbsp;</td><td>
<p>Purple. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a94a58a580a0576ea1f28a2564774f95a"></a><!-- doxytag: member="StreamColor_Teal" ref="a118f2d350ecce997af3f9e1c817fa321a94a58a580a0576ea1f28a2564774f95a" args="" -->StreamColor_Teal</em>&nbsp;</td><td>
<p>Teal. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a6352965a77351604a4fb449f66df96e6"></a><!-- doxytag: member="StreamColor_LightGray" ref="a118f2d350ecce997af3f9e1c817fa321a6352965a77351604a4fb449f66df96e6" args="" -->StreamColor_LightGray</em>&nbsp;</td><td>
<p>LightGray. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321af8cbac1491dc0aa4350d410c7979610a"></a><!-- doxytag: member="StreamColor_DarkGray" ref="a118f2d350ecce997af3f9e1c817fa321af8cbac1491dc0aa4350d410c7979610a" args="" -->StreamColor_DarkGray</em>&nbsp;</td><td>
<p>Dark Gray. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a0191c01a1ae8a0f32513e6d435a035b4"></a><!-- doxytag: member="StreamColor_Red" ref="a118f2d350ecce997af3f9e1c817fa321a0191c01a1ae8a0f32513e6d435a035b4" args="" -->StreamColor_Red</em>&nbsp;</td><td>
<p>Red. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a7fb90bd6188ea53c9f501f07278639dc"></a><!-- doxytag: member="StreamColor_Green" ref="a118f2d350ecce997af3f9e1c817fa321a7fb90bd6188ea53c9f501f07278639dc" args="" -->StreamColor_Green</em>&nbsp;</td><td>
<p>Green. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321ab65ac4782da71d06fc5033877df7a342"></a><!-- doxytag: member="StreamColor_Yellow" ref="a118f2d350ecce997af3f9e1c817fa321ab65ac4782da71d06fc5033877df7a342" args="" -->StreamColor_Yellow</em>&nbsp;</td><td>
<p>Yellow. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a49b1c68c9ae2782eb143a3a66dae3d55"></a><!-- doxytag: member="StreamColor_Blue" ref="a118f2d350ecce997af3f9e1c817fa321a49b1c68c9ae2782eb143a3a66dae3d55" args="" -->StreamColor_Blue</em>&nbsp;</td><td>
<p>Blue. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321a68b9f3474d708de9bbbcfa8ee81f822b"></a><!-- doxytag: member="StreamColor_Fuchsia" ref="a118f2d350ecce997af3f9e1c817fa321a68b9f3474d708de9bbbcfa8ee81f822b" args="" -->StreamColor_Fuchsia</em>&nbsp;</td><td>
<p>Fuchsia. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321ac19037b0d7b1c1a760e7182f3b598091"></a><!-- doxytag: member="StreamColor_Turquoise" ref="a118f2d350ecce997af3f9e1c817fa321ac19037b0d7b1c1a760e7182f3b598091" args="" -->StreamColor_Turquoise</em>&nbsp;</td><td>
<p>Turquoise. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a118f2d350ecce997af3f9e1c817fa321af2db4cdda545b6e45843235be74f637f"></a><!-- doxytag: member="StreamColor_White" ref="a118f2d350ecce997af3f9e1c817fa321af2db4cdda545b6e45843235be74f637f" args="" -->StreamColor_White</em>&nbsp;</td><td>
<p>White. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00362_source.html#l00019">19</a> of file <a class="el" href="a00362_source.html">iocolor.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae01d947882857905031a3773561d3d83"></a><!-- doxytag: member="qi::TypeKind" ref="ae01d947882857905031a3773561d3d83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83">qi::TypeKind</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a9addb80987fbf6aba929a8ba36a8696a"></a><!-- doxytag: member="TypeKind_Unknown" ref="ae01d947882857905031a3773561d3d83a9addb80987fbf6aba929a8ba36a8696a" args="" -->TypeKind_Unknown</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a697124369f8d09989eb1799cc5b417f1"></a><!-- doxytag: member="TypeKind_Void" ref="ae01d947882857905031a3773561d3d83a697124369f8d09989eb1799cc5b417f1" args="" -->TypeKind_Void</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a5c9f02f8fde69ebf4ef298429f406ca1"></a><!-- doxytag: member="TypeKind_Int" ref="ae01d947882857905031a3773561d3d83a5c9f02f8fde69ebf4ef298429f406ca1" args="" -->TypeKind_Int</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ac2cb42a5ad96ca81820b32883ff11ce1"></a><!-- doxytag: member="TypeKind_Float" ref="ae01d947882857905031a3773561d3d83ac2cb42a5ad96ca81820b32883ff11ce1" args="" -->TypeKind_Float</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a0cea76e7d2e7ca23952106e2df8e5477"></a><!-- doxytag: member="TypeKind_String" ref="ae01d947882857905031a3773561d3d83a0cea76e7d2e7ca23952106e2df8e5477" args="" -->TypeKind_String</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a2d80d8ac34eb816f880492fd48fa9947"></a><!-- doxytag: member="TypeKind_List" ref="ae01d947882857905031a3773561d3d83a2d80d8ac34eb816f880492fd48fa9947" args="" -->TypeKind_List</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a02c298fe28a07aa0fd52762c6ead1f49"></a><!-- doxytag: member="TypeKind_Map" ref="ae01d947882857905031a3773561d3d83a02c298fe28a07aa0fd52762c6ead1f49" args="" -->TypeKind_Map</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a3fdef608736434b0ed3db23409166f45"></a><!-- doxytag: member="TypeKind_Object" ref="ae01d947882857905031a3773561d3d83a3fdef608736434b0ed3db23409166f45" args="" -->TypeKind_Object</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ac588aa7668f30929b99f7b51e164d85e"></a><!-- doxytag: member="TypeKind_Pointer" ref="ae01d947882857905031a3773561d3d83ac588aa7668f30929b99f7b51e164d85e" args="" -->TypeKind_Pointer</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ae256bb50e674644be82c9e3c875b17b1"></a><!-- doxytag: member="TypeKind_Tuple" ref="ae01d947882857905031a3773561d3d83ae256bb50e674644be82c9e3c875b17b1" args="" -->TypeKind_Tuple</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ad4857d8288ae9b6587dbbe3a60afb7b1"></a><!-- doxytag: member="TypeKind_Dynamic" ref="ae01d947882857905031a3773561d3d83ad4857d8288ae9b6587dbbe3a60afb7b1" args="" -->TypeKind_Dynamic</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a629950116208ae3ec5707f826f77394a"></a><!-- doxytag: member="TypeKind_Raw" ref="ae01d947882857905031a3773561d3d83a629950116208ae3ec5707f826f77394a" args="" -->TypeKind_Raw</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a053d4b330c4a9e259ddedd9bd8571ba3"></a><!-- doxytag: member="TypeKind_Iterator" ref="ae01d947882857905031a3773561d3d83a053d4b330c4a9e259ddedd9bd8571ba3" args="" -->TypeKind_Iterator</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a93d64a5491fde8c3736899b963ed84b6"></a><!-- doxytag: member="TypeKind_Function" ref="ae01d947882857905031a3773561d3d83a93d64a5491fde8c3736899b963ed84b6" args="" -->TypeKind_Function</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83ade474d4acfbe0a14655b407dde022904"></a><!-- doxytag: member="TypeKind_Signal" ref="ae01d947882857905031a3773561d3d83ade474d4acfbe0a14655b407dde022904" args="" -->TypeKind_Signal</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a657d2054debc55771add5e8c42987a26"></a><!-- doxytag: member="TypeKind_Property" ref="ae01d947882857905031a3773561d3d83a657d2054debc55771add5e8c42987a26" args="" -->TypeKind_Property</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae01d947882857905031a3773561d3d83a94150a53653301f2fefce04752093ef9"></a><!-- doxytag: member="TypeKind_VarArgs" ref="ae01d947882857905031a3773561d3d83a94150a53653301f2fefce04752093ef9" args="" -->TypeKind_VarArgs</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="a00432_source.html#l00053">53</a> of file <a class="el" href="a00432_source.html">fwd.hpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae3ab25935968b983ded9bf5211a9b173"></a><!-- doxytag: member="qi::adaptFuture" ref="ae3ab25935968b983ded9bf5211a9b173" args="(const Future&lt; FT &gt; &amp;f, Promise&lt; PT &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename PT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#ae3ab25935968b983ded9bf5211a9b173">qi::adaptFuture</a> </td>
          <td>(</td>
          <td class="paramtype">const Future&lt; FT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Promise&lt; PT &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Feed a promise from a future of possibly different type. </p>
<p>Will monitor <code>f</code>, and bounce its state to <code>p</code>. Error and canceled state are bounced as is. Valued state is bounced through FutureValueConverter&lt;FT, PT&gt;::convert() </p>

<p>Definition at line <a class="el" href="a00351_source.html#l00375">375</a> of file <a class="el" href="a00351_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="afcd48f3c1a84d796d798e757cc12e2b8"></a><!-- doxytag: member="qi::adaptFuture" ref="afcd48f3c1a84d796d798e757cc12e2b8" args="(const Future&lt; FT &gt; &amp;f, Promise&lt; PT &gt; &amp;p, CONV converter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename PT , typename CONV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#ae3ab25935968b983ded9bf5211a9b173">qi::adaptFuture</a> </td>
          <td>(</td>
          <td class="paramtype">const Future&lt; FT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Promise&lt; PT &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONV&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to adaptFuture(f, p) but with a custom converter. </p>

<p>Definition at line <a class="el" href="a00351_source.html#l00385">385</a> of file <a class="el" href="a00351_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a41c2015abb2b45d42f54a2558def93e3"></a><!-- doxytag: member="qi::asAnyReferenceVector" ref="a41c2015abb2b45d42f54a2558def93e3" args="(const AnyValueVector &amp;vect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a> <a class="el" href="a00359.html#a41c2015abb2b45d42f54a2558def93e3">qi::asAnyReferenceVector</a> </td>
          <td>(</td>
          <td class="paramtype">const AnyValueVector &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00402_source.html#l00211">211</a> of file <a class="el" href="a00402_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a56fc521d5d2aef7f999b479579904cf4"></a><!-- doxytag: member="qi::async" ref="a56fc521d5d2aef7f999b479579904cf4" args="(T instancePointerOrSharedPointer, const std::string &amp;methodName, qi::AutoAnyReference p1=qi::AutoAnyReference(), qi::AutoAnyReference p2=qi::AutoAnyReference(), qi::AutoAnyReference p3=qi::AutoAnyReference(), qi::AutoAnyReference p4=qi::AutoAnyReference(), qi::AutoAnyReference p5=qi::AutoAnyReference(), qi::AutoAnyReference p6=qi::AutoAnyReference(), qi::AutoAnyReference p7=qi::AutoAnyReference(), qi::AutoAnyReference p8=qi::AutoAnyReference())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">qi::Future</a>&lt;R&gt; <a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">qi::async</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>instancePointerOrSharedPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>methodName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p1</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p2</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p3</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p4</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p5</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p6</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p7</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00028.html">qi::AutoAnyReference</a>&#160;</td>
          <td class="paramname"><em>p8</em> = <code><a class="el" href="a00028.html">qi::AutoAnyReference</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform an asynchronous call on a method. The argument may be a pointer or shared-pointer to an instance of a class known to type system. </p>

</div>
</div>
<a class="anchor" id="a64c067d0268ca324a6783c1ad0c43155"></a><!-- doxytag: member="qi::async" ref="a64c067d0268ca324a6783c1ad0c43155" args="(boost::function&lt; R()&gt; callback, uint64_t usDelay=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">Future</a>&lt;R&gt; <a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">qi::async</a> </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>usDelay</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call given function once after given delay in microseconds. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Callback to be called. </td></tr>
    <tr><td class="paramname">usDelay</td><td>Delay before call the callback in microsecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A canceleable future. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="a00458.html#_deprecated000004">Deprecated:</a></b></dt><dd>use <a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">qi::async</a> with <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e" title="Convenience typedefs.">qi::Duration</a> </dd></dl>
. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00458.html#_deprecated000003">Deprecated:</a></b></dt><dd>use <a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">qi::async</a> with <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e" title="Convenience typedefs.">qi::Duration</a> </dd></dl>

<p>Definition at line <a class="el" href="a00358_source.html#l00176">176</a> of file <a class="el" href="a00358_source.html">eventloop.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9c797a4346eb3238c8f666f3450d6b0"></a><!-- doxytag: member="qi::async" ref="af9c797a4346eb3238c8f666f3450d6b0" args="(boost::function&lt; R()&gt; callback, qi::Duration delay)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">Future</a>&lt;R&gt; <a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">qi::async</a> </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">qi::Duration</a>&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00358_source.html#l00181">181</a> of file <a class="el" href="a00358_source.html">eventloop.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a921f4c45f023391fa581f83cc75734bc"></a><!-- doxytag: member="qi::async" ref="a921f4c45f023391fa581f83cc75734bc" args="(boost::function&lt; R()&gt; callback, qi::SteadyClockTimePoint timepoint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">Future</a>&lt;R&gt; <a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">qi::async</a> </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; R()&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00359.html#ab752bd54724652b6a0b86bd680b434de">qi::SteadyClockTimePoint</a>&#160;</td>
          <td class="paramname"><em>timepoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00358_source.html#l00186">186</a> of file <a class="el" href="a00358_source.html">eventloop.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a989ea5d8d0b3bfb75e1daefb30252071"></a><!-- doxytag: member="qi::async" ref="a989ea5d8d0b3bfb75e1daefb30252071" args="(const Func &amp;f, const ArgTrack &amp;toTrack,...)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename Func , typename ArgTrack &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">qi::Future</a>&lt;R&gt; <a class="el" href="a00359.html#a64c067d0268ca324a6783c1ad0c43155">qi::async</a> </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgTrack &amp;&#160;</td>
          <td class="paramname"><em>toTrack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a22ca99743b6c820547dea46057a73ae0"></a><!-- doxytag: member="qi::bind" ref="a22ca99743b6c820547dea46057a73ae0" args="(const AF &amp;fun,...)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RF , typename AF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;RF&gt; <a class="el" href="a00359.html#a22ca99743b6c820547dea46057a73ae0">qi::bind</a> </td>
          <td>(</td>
          <td class="paramtype">const AF &amp;&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind a set of arguments or placeholders to a function.</p>
<p>Handles first function argument of kind boost::weak_ptr and <a class="el" href="a00281.html" title="Object tracking by blocking destruction while shared pointers are present.">qi::Trackable</a>: will try to lock and throw <a class="el" href="a00252.html">qi::PointerLockException</a> in case of failure </p>

</div>
</div>
<a class="anchor" id="a17b1ac2d7a040d3644e751eb1bc602ed"></a><!-- doxytag: member="qi::decodeBinary" ref="a17b1ac2d7a040d3644e751eb1bc602ed" args="(qi::BufferReader *buf, T *value, DeserializeObjectCallback onObject=DeserializeObjectCallback(), StreamContext *streamContext=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a17b1ac2d7a040d3644e751eb1bc602ed">qi::decodeBinary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00037.html">qi::BufferReader</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeserializeObjectCallback&#160;</td>
          <td class="paramname"><em>onObject</em> = <code>DeserializeObjectCallback()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamContext *&#160;</td>
          <td class="paramname"><em>streamContext</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00344_source.html#l00142">142</a> of file <a class="el" href="a00344_source.html">binarycodec.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a71cf39de46afdc30a510d03200dc6ea2"></a><!-- doxytag: member="qi::decodeBinary" ref="a71cf39de46afdc30a510d03200dc6ea2" args="(qi::BufferReader *buf, AnyReference gvp, DeserializeObjectCallback onObject=DeserializeObjectCallback(), StreamContext *ctx=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a17b1ac2d7a040d3644e751eb1bc602ed">qi::decodeBinary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00037.html">qi::BufferReader</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyReference&#160;</td>
          <td class="paramname"><em>gvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeserializeObjectCallback&#160;</td>
          <td class="paramname"><em>onObject</em> = <code>DeserializeObjectCallback()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamContext *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decode content of <code>buf</code> into <code>gvp</code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer with serialized data </td></tr>
    <tr><td class="paramname">gvp</td><td>initialized <a class="el" href="a00023.html">AnyReference</a> of correct type. Will be filled in. </td></tr>
    <tr><td class="paramname">onObject</td><td>callback invoked each time an object is encountered. </td></tr>
    <tr><td class="paramname">ctx</td><td>connection context</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the decoding fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc0f8ab49ff6d865e791e8fd84ffa212"></a><!-- doxytag: member="qi::decodeJSON" ref="abc0f8ab49ff6d865e791e8fd84ffa212" args="(const std::string &amp;in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00024.html">qi::AnyValue</a> <a class="el" href="a00359.html#abc0f8ab49ff6d865e791e8fd84ffa212">qi::decodeJSON</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>creates a GV representing a JSON string or throw on parse error. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>JSON string to decode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a GV representing the JSON string </dd></dl>

</div>
</div>
<a class="anchor" id="aefbddfd2b5c63e97a33bb1f4583a64ad"></a><!-- doxytag: member="qi::decodeJSON" ref="aefbddfd2b5c63e97a33bb1f4583a64ad" args="(const std::string::const_iterator &amp;begin, const std::string::const_iterator &amp;end, AnyValue &amp;target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string::const_iterator <a class="el" href="a00359.html#abc0f8ab49ff6d865e791e8fd84ffa212">qi::decodeJSON</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyValue &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>set the input GV to represent the JSON sequence between two string iterators or throw on parse error. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>iterator to the beginning of the sequence to decode. </td></tr>
    <tr><td class="paramname">end</td><td>iterator to the end of the sequence to decode. </td></tr>
    <tr><td class="paramname">target</td><td>GV to set. Not modified if an error occured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an iterator to the last read char + 1 </dd></dl>

</div>
</div>
<a class="anchor" id="ad774296b27b62b0ca406b6d15c4fd170"></a><!-- doxytag: member="qi::defaultTranslator" ref="ad774296b27b62b0ca406b6d15c4fd170" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00283.html">qi::Translator</a>&amp; <a class="el" href="a00359.html#ad774296b27b62b0ca406b6d15c4fd170">qi::defaultTranslator</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference on the default <a class="el" href="a00283.html" title="Localization of your source code.">Translator</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td><a class="el" href="a00025.html" title="Class handling startup and teardown of an application.">Application</a> or Library name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference on default <a class="el" href="a00283.html" title="Localization of your source code.">qi::Translator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a098783b698f8b1042afa3fcb13fb2d75"></a><!-- doxytag: member="qi::dynamicFunctionTypeInterface" ref="a098783b698f8b1042afa3fcb13fb2d75" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html">FunctionTypeInterface</a>* <a class="el" href="a00359.html#a098783b698f8b1042afa3fcb13fb2d75">qi::dynamicFunctionTypeInterface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the type used by dynamic functions </dd></dl>

</div>
</div>
<a class="anchor" id="afb540c3b6650f31ca7695cb2bccd69cb"></a><!-- doxytag: member="qi::encodeBinary" ref="afb540c3b6650f31ca7695cb2bccd69cb" args="(qi::Buffer *buf, const AutoAnyReference &amp;gvp, SerializeObjectCallback onObject=SerializeObjectCallback(), StreamContext *ctx=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#afb540c3b6650f31ca7695cb2bccd69cb">qi::encodeBinary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00036.html">qi::Buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AutoAnyReference &amp;&#160;</td>
          <td class="paramname"><em>gvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SerializeObjectCallback&#160;</td>
          <td class="paramname"><em>onObject</em> = <code>SerializeObjectCallback()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StreamContext *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Encode content of <code>gvp</code> into <code>buf</code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>buffer that will be filled with serialized data </td></tr>
    <tr><td class="paramname">gvp</td><td><a class="el" href="a00023.html">AnyReference</a> to serialize </td></tr>
    <tr><td class="paramname">onObject</td><td>callback invoked each time an object is encountered. </td></tr>
    <tr><td class="paramname">ctx</td><td>connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the encoding fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a320299dc29443998767ead43d180da8b"></a><!-- doxytag: member="qi::encodeJSON" ref="a320299dc29443998767ead43d180da8b" args="(const qi::AutoAnyReference &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="a00359.html#a320299dc29443998767ead43d180da8b">qi::encodeJSON</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00028.html">qi::AutoAnyReference</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the value encoded in JSON. </dd></dl>

</div>
</div>
<a class="anchor" id="acde1dffa366528f25db3597abb0b2fe5"></a><!-- doxytag: member="qi::getDynamicTypeInterface" ref="acde1dffa366528f25db3597abb0b2fe5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00247.html">ObjectTypeInterface</a>* <a class="el" href="a00359.html#acde1dffa366528f25db3597abb0b2fe5">qi::getDynamicTypeInterface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6a56d0b369a9a5eeb3655db91c684c4"></a><!-- doxytag: member="qi::getEventLoop" ref="ac6a56d0b369a9a5eeb3655db91c684c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00197.html">EventLoop</a>* <a class="el" href="a00359.html#ac6a56d0b369a9a5eeb3655db91c684c4">qi::getEventLoop</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the global eventloop, created on demand on first call. </p>

</div>
</div>
<a class="anchor" id="aa3ee2a95759c087e0cdadbe608a1ac59"></a><!-- doxytag: member="qi::getIoService" ref="aa3ee2a95759c087e0cdadbe608a1ac59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::io_service&amp; <a class="el" href="a00359.html#aa3ee2a95759c087e0cdadbe608a1ac59">qi::getIoService</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the io_service used by the global event loop. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>io_service used by the global event loop. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7d0e709c6dd1b32ddd4d9a427926ea5"></a><!-- doxytag: member="qi::getRegisteredStruct" ref="ad7d0e709c6dd1b32ddd4d9a427926ea5" args="(const qi::Signature &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#ad7d0e709c6dd1b32ddd4d9a427926ea5">qi::getRegisteredStruct</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00270.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>matching <a class="el" href="a00315.html">TypeInterface</a> registered by <a class="el" href="a00359.html#ae5acba1383706c293755c20935f7d613">registerStruct()</a> or 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a28374f6240c824f5c32b7d3a30e6ba0c"></a><!-- doxytag: member="qi::getType" ref="a28374f6240c824f5c32b7d3a30e6ba0c" args="(const std::type_info &amp;type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#a28374f6240c824f5c32b7d3a30e6ba0c">qi::getType</a> </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runtime Type factory getter. Used by <a class="el" href="a00359.html#a45c4fec4058dee00453ef20d1c544eec">typeOf&lt;T&gt;()</a> </p>

</div>
</div>
<a class="anchor" id="a5882f25a3446993872bf1203d8ac5243"></a><!-- doxytag: member="qi::import" ref="a5882f25a3446993872bf1203d8ac5243" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">AnyModule</a> <a class="el" href="a00359.html#a5882f25a3446993872bf1203d8ac5243">qi::import</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>find a module and import it, this is cross language, that's the main module entry point</p>
<p>this function dispatch to &lt;lang&gt; module factory, if the module is not already registered </p>

</div>
</div>
<a class="anchor" id="ac2d8256b364ab12d3b96d6bb3832b60e"></a><!-- doxytag: member="qi::import" ref="ac2d8256b364ab12d3b96d6bb3832b60e" args="(const ModuleInfo &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">AnyModule</a> <a class="el" href="a00359.html#a5882f25a3446993872bf1203d8ac5243">qi::import</a> </td>
          <td>(</td>
          <td class="paramtype">const ModuleInfo &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af68bfc01c21c9742b95d9cd5dbfd383f"></a><!-- doxytag: member="qi::listModules" ref="af68bfc01c21c9742b95d9cd5dbfd383f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00243.html">ModuleInfo</a>&gt; <a class="el" href="a00359.html#af68bfc01c21c9742b95d9cd5dbfd383f">qi::listModules</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>list all available modules (cross language </p>

</div>
</div>
<a class="anchor" id="a04d6828dff16659a53da08c7de30956f"></a><!-- doxytag: member="qi::makeDynamicAnyObject" ref="a04d6828dff16659a53da08c7de30956f" args="(DynamicObject *obj, bool destroyObject=true, boost::function&lt; void(GenericObject *)&gt; onDelete=boost::function&lt; void(GenericObject *)&gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> <a class="el" href="a00359.html#a04d6828dff16659a53da08c7de30956f">qi::makeDynamicAnyObject</a> </td>
          <td>(</td>
          <td class="paramtype">DynamicObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>destroyObject</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(GenericObject *)&gt;&#160;</td>
          <td class="paramname"><em>onDelete</em> = <code>boost::function&lt;&#160;void(GenericObject&#160;*)&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a230889c807a35900df1fb6385a926a98"></a><!-- doxytag: member="qi::makeDynamicSharedAnyObject" ref="a230889c807a35900df1fb6385a926a98" args="(DynamicObject *obj, boost::shared_ptr&lt; T &gt; other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> <a class="el" href="a00359.html#a230889c807a35900df1fb6385a926a98">qi::makeDynamicSharedAnyObject</a> </td>
          <td>(</td>
          <td class="paramtype">DynamicObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make an AnyObject that shares its ref counter with <code>other</code> Note that <code>obj</code> will not be destroyed when the shared counter reaches 0. </p>

<p>Definition at line <a class="el" href="a00430_source.html#l00081">81</a> of file <a class="el" href="a00430_source.html">dynamicobject.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a631fd1daf49d80aa9abb8210efc13769"></a><!-- doxytag: member="qi::makeDynamicSharedAnyObjectImpl" ref="a631fd1daf49d80aa9abb8210efc13769" args="(DynamicObject *obj, boost::shared_ptr&lt; Empty &gt; other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a0e60a9cbccf0a2138b4f838b9ccd356a">AnyObject</a> <a class="el" href="a00359.html#a631fd1daf49d80aa9abb8210efc13769">qi::makeDynamicSharedAnyObjectImpl</a> </td>
          <td>(</td>
          <td class="paramtype">DynamicObject *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; Empty &gt;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae09c8c0d171c2ef5e3b2c4db795d8db4"></a><!-- doxytag: member="qi::makeFloatType" ref="ae09c8c0d171c2ef5e3b2c4db795d8db4" args="(int bytelen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#ae09c8c0d171c2ef5e3b2c4db795d8db4">qi::makeFloatType</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytelen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Type of kind float, bytelen can be 4 or 8 </dd></dl>

</div>
</div>
<a class="anchor" id="af824fdaacc150d8140e14cedebc08f8d"></a><!-- doxytag: member="qi::makeFunctionTypeInterface" ref="af824fdaacc150d8140e14cedebc08f8d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00202.html">FunctionTypeInterface</a>* <a class="el" href="a00359.html#af824fdaacc150d8140e14cedebc08f8d">qi::makeFunctionTypeInterface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad14f72235d0dd750a72c972d59d6531a"></a><!-- doxytag: member="qi::makeFutureError" ref="ad14f72235d0dd750a72c972d59d6531a" args="(const std::string &amp;error)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">qi::Future</a>&lt; T &gt; <a class="el" href="a00359.html#ad14f72235d0dd750a72c972d59d6531a">qi::makeFutureError</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to return a future with the error set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>the error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00351_source.html#l00290">290</a> of file <a class="el" href="a00351_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a0677f9994ab898cc93a8131b83bd2102"></a><!-- doxytag: member="qi::makeGenericTuple" ref="a0677f9994ab898cc93a8131b83bd2102" args="(const AnyReferenceVector &amp;values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">AnyReference</a> <a class="el" href="a00359.html#a0677f9994ab898cc93a8131b83bd2102">qi::makeGenericTuple</a> </td>
          <td>(</td>
          <td class="paramtype">const AnyReferenceVector &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>an allocated Tuple made from copies of </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f7d98cfcf8874b647ce4fbfbb0040ee"></a><!-- doxytag: member="qi::makeGenericTuplePtr" ref="a2f7d98cfcf8874b647ce4fbfbb0040ee" args="(const std::vector&lt; TypeInterface * &gt; &amp;types, const std::vector&lt; void * &gt; &amp;values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html">AnyReference</a> <a class="el" href="a00359.html#a2f7d98cfcf8874b647ce4fbfbb0040ee">qi::makeGenericTuplePtr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TypeInterface * &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Tuple pointing to values as its storage </dd></dl>

</div>
</div>
<a class="anchor" id="a426b195e4c91c436ffe1a3230ec5f712"></a><!-- doxytag: member="qi::makeIntType" ref="a426b195e4c91c436ffe1a3230ec5f712" args="(bool issigned, int bytelen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#a426b195e4c91c436ffe1a3230ec5f712">qi::makeIntType</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>issigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytelen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Type of kind int, bytelen can be 0,1,2,4,8 </dd></dl>

</div>
</div>
<a class="anchor" id="a481997bd83b95542e6372d1d94456022"></a><!-- doxytag: member="qi::makeKwArgsSignature" ref="a481997bd83b95542e6372d1d94456022" args="(const qi::Signature &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00270.html">qi::Signature</a> <a class="el" href="a00359.html#a481997bd83b95542e6372d1d94456022">qi::makeKwArgsSignature</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00270.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a03e3b32ae885f36dc89d1f72f91878bd"></a><!-- doxytag: member="qi::makeListSignature" ref="a03e3b32ae885f36dc89d1f72f91878bd" args="(const qi::Signature &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00270.html">qi::Signature</a> <a class="el" href="a00359.html#a03e3b32ae885f36dc89d1f72f91878bd">qi::makeListSignature</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00270.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ada86c6a16b6970d55b47851227487f"></a><!-- doxytag: member="qi::makeListType" ref="a4ada86c6a16b6970d55b47851227487f" args="(TypeInterface *elementType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#a4ada86c6a16b6970d55b47851227487f">qi::makeListType</a> </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>elementType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Type of kind List that can contains elements of type elementType. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e4e963b37472078c2a9d927b44ef97d"></a><!-- doxytag: member="qi::makeMapSignature" ref="a0e4e963b37472078c2a9d927b44ef97d" args="(const qi::Signature &amp;key, const qi::Signature &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00270.html">qi::Signature</a> <a class="el" href="a00359.html#a0e4e963b37472078c2a9d927b44ef97d">qi::makeMapSignature</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00270.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00270.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84d0f507e9bcd84530c9650100c17a67"></a><!-- doxytag: member="qi::makeMapType" ref="a84d0f507e9bcd84530c9650100c17a67" args="(TypeInterface *keyType, TypeInterface *ElementType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#a84d0f507e9bcd84530c9650100c17a67">qi::makeMapType</a> </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>keyType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>ElementType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Type of kind Map with given key and element types </dd></dl>

</div>
</div>
<a class="anchor" id="a6ede9f79bfd42c877ce4c913e1d477b3"></a><!-- doxytag: member="qi::makeProxyProperty" ref="a6ede9f79bfd42c877ce4c913e1d477b3" args="(Property&lt; T &gt; &amp;target, AnyObject object, const std::string &amp;signalName)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a6ede9f79bfd42c877ce4c913e1d477b3">qi::makeProxyProperty</a> </td>
          <td>(</td>
          <td class="paramtype">Property&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00438_source.html#l00047">47</a> of file <a class="el" href="a00438_source.html">proxyproperty.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2f3450ea4977e6106d71d1b43fd231ba"></a><!-- doxytag: member="qi::makeProxyProperty" ref="a2f3450ea4977e6106d71d1b43fd231ba" args="(ProxyProperty&lt; T &gt; &amp;target, AnyObject object, const std::string &amp;signalName)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a6ede9f79bfd42c877ce4c913e1d477b3">qi::makeProxyProperty</a> </td>
          <td>(</td>
          <td class="paramtype">ProxyProperty&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00438_source.html#l00053">53</a> of file <a class="el" href="a00438_source.html">proxyproperty.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4ab95a69a97a75ef18b2337ac5a5932"></a><!-- doxytag: member="qi::makeProxySignal" ref="ab4ab95a69a97a75ef18b2337ac5a5932" args="(SignalF&lt; T &gt; &amp;target, AnyObject object, const std::string &amp;signalName)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#ab4ab95a69a97a75ef18b2337ac5a5932">qi::makeProxySignal</a> </td>
          <td>(</td>
          <td class="paramtype">SignalF&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00439_source.html#l00043">43</a> of file <a class="el" href="a00439_source.html">proxysignal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a748adf53e6743b399564d041658ad6ab"></a><!-- doxytag: member="qi::makeProxySignal" ref="a748adf53e6743b399564d041658ad6ab" args="(ProxySignal&lt; T &gt; &amp;target, AnyObject object, const std::string &amp;signalName)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#ab4ab95a69a97a75ef18b2337ac5a5932">qi::makeProxySignal</a> </td>
          <td>(</td>
          <td class="paramtype">ProxySignal&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>signalName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00439_source.html#l00050">50</a> of file <a class="el" href="a00439_source.html">proxysignal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e685d2199df078c6aa5524943776d7"></a><!-- doxytag: member="qi::makeSession" ref="a36e685d2199df078c6aa5524943776d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#ae3f87eaf6b8d541402a41d14a8b33816">SessionPtr</a> <a class="el" href="a00359.html#a36e685d2199df078c6aa5524943776d7">qi::makeSession</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00388_source.html#l00114">114</a> of file <a class="el" href="a00388_source.html">session.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a57e7b45e3cfcd1b27585b5776c268642"></a><!-- doxytag: member="qi::makeTupleSignature" ref="a57e7b45e3cfcd1b27585b5776c268642" args="(const std::vector&lt; qi::AnyReference &gt; &amp;vgv, bool resolveDynamic=false, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00270.html">qi::Signature</a> <a class="el" href="a00359.html#a57e7b45e3cfcd1b27585b5776c268642">qi::makeTupleSignature</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00023.html">qi::AnyReference</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vgv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resolveDynamic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa0f39be2e53755f32bc54f278b92f6dc"></a><!-- doxytag: member="qi::makeTupleSignature" ref="aa0f39be2e53755f32bc54f278b92f6dc" args="(const std::vector&lt; TypeInterface * &gt; &amp;vgv, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00270.html">qi::Signature</a> <a class="el" href="a00359.html#a57e7b45e3cfcd1b27585b5776c268642">qi::makeTupleSignature</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TypeInterface * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vgv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa258277993d928c87aed1a62bc8d900"></a><!-- doxytag: member="qi::makeTupleSignature" ref="aaa258277993d928c87aed1a62bc8d900" args="(const qi::Signature &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00270.html">qi::Signature</a> <a class="el" href="a00359.html#a57e7b45e3cfcd1b27585b5776c268642">qi::makeTupleSignature</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00270.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7eaf3d66d510df1dd23529d3f4f20631"></a><!-- doxytag: member="qi::makeTupleType" ref="a7eaf3d66d510df1dd23529d3f4f20631" args="(const std::vector&lt; TypeInterface * &gt; &amp;memberTypes, const std::string &amp;name=std::string(), const std::vector&lt; std::string &gt; &amp;elementNames=std::vector&lt; std::string &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#a7eaf3d66d510df1dd23529d3f4f20631">qi::makeTupleType</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; TypeInterface * &gt; &amp;&#160;</td>
          <td class="paramname"><em>memberTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>elementNames</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Type of kind Tuple with givent memberTypes </dd></dl>

</div>
</div>
<a class="anchor" id="a23e607036093eb12c791c880d865e5d5"></a><!-- doxytag: member="qi::makeTypeEquivalentString" ref="a23e607036093eb12c791c880d865e5d5" args="(T *, F f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00274.html">StringTypeInterface</a>* <a class="el" href="a00359.html#a23e607036093eb12c791c880d865e5d5">qi::makeTypeEquivalentString</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00421_source.html#l00142">142</a> of file <a class="el" href="a00421_source.html">stringtypeinterface.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ad88d038b69d6ddd1416c07784d4c2854"></a><!-- doxytag: member="qi::makeTypeOfKind" ref="ad88d038b69d6ddd1416c07784d4c2854" args="(const qi::TypeKind &amp;kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#ad88d038b69d6ddd1416c07784d4c2854">qi::makeTypeOfKind</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00359.html#ae01d947882857905031a3773561d3d83">qi::TypeKind</a> &amp;&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Type of the specified Kind. This do not work for list, map and tuple. kind Int and Float will create the biggest possible type. use makeFloatType and makeIntType to be more specific. </dd></dl>

</div>
</div>
<a class="anchor" id="a67377d0f4a7dddc54912d96031b4b06e"></a><!-- doxytag: member="qi::makeVarArgsSignature" ref="a67377d0f4a7dddc54912d96031b4b06e" args="(const qi::Signature &amp;element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00270.html">qi::Signature</a> <a class="el" href="a00359.html#a67377d0f4a7dddc54912d96031b4b06e">qi::makeVarArgsSignature</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00270.html">qi::Signature</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a537adf368dd07b2b5d5a248780f4f768"></a><!-- doxytag: member="qi::makeVarArgsType" ref="a537adf368dd07b2b5d5a248780f4f768" args="(TypeInterface *elementType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#a537adf368dd07b2b5d5a248780f4f768">qi::makeVarArgsType</a> </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>elementType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a Type of kind VarArgs that can contains elements of type elementType. </dd></dl>

</div>
</div>
<a class="anchor" id="aab97cd68b446e79163130ece29d2c5f0"></a><!-- doxytag: member="qi::metaCall" ref="aab97cd68b446e79163130ece29d2c5f0" args="(ExecutionContext *ec, ObjectThreadingModel objectThreadingModel, MetaCallType methodThreadingModel, MetaCallType callType, AnyObject manageable, unsigned int methodId, AnyFunction func, const GenericFunctionParameters &amp;params, bool noCloneFirst=false, unsigned int callerId=0, qi::os::timeval postTimestamp=qi::os::timeval())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00010.html">qi::Future</a>&lt;<a class="el" href="a00023.html">AnyReference</a>&gt; <a class="el" href="a00359.html#aab97cd68b446e79163130ece29d2c5f0">qi::metaCall</a> </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectThreadingModel&#160;</td>
          <td class="paramname"><em>objectThreadingModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetaCallType&#160;</td>
          <td class="paramname"><em>methodThreadingModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MetaCallType&#160;</td>
          <td class="paramname"><em>callType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyObject&#160;</td>
          <td class="paramname"><em>manageable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>methodId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyFunction&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GenericFunctionParameters &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noCloneFirst</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>callerId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00249.html">qi::os::timeval</a>&#160;</td>
          <td class="paramname"><em>postTimestamp</em> = <code><a class="el" href="a00249.html">qi::os::timeval</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a call honoring ThreadingModel requirements</p>
<p>Check the following rules in order:</p>
<ul>
<li>If methodThreadingModel is not auto, honor it, overriding callType</li>
<li>If callType is set (not auto), honor it.</li>
<li>If el is set, force call in it (synchronously if we are in it).</li>
<li>Be synchronous.</li>
</ul>
<p>When the call is finally made, if objectThreadingModel is SingleThread, acquire the object lock.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>context into which the call will be scheduled </td></tr>
    <tr><td class="paramname">objectThreadingModel</td><td>the threading model of the called object </td></tr>
    <tr><td class="paramname">methodThreadingModel</td><td>the threading model of the specific method </td></tr>
    <tr><td class="paramname">callType</td><td>the requested threading model </td></tr>
    <tr><td class="paramname">manageable</td><td>the object on which to make the call </td></tr>
    <tr><td class="paramname">methodId</td><td>the method id of the object to call </td></tr>
    <tr><td class="paramname">func</td><td>the function to call </td></tr>
    <tr><td class="paramname">params</td><td>the arguments of the call </td></tr>
    <tr><td class="paramname">noCloneFirst</td><td>whether the first argument of the call should be cloned or not </td></tr>
    <tr><td class="paramname">callerId</td><td>thread id of caller, for tracing purposes </td></tr>
    <tr><td class="paramname">postTimestamp</td><td>the time when the call was requested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86d3fe036a58d21b7fe41fb71bf4cd95"></a><!-- doxytag: member="qi::nullConverter" ref="a86d3fe036a58d21b7fe41fb71bf4cd95" args="(void *, R &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a86d3fe036a58d21b7fe41fb71bf4cd95">qi::nullConverter</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00349_source.html#l00017">17</a> of file <a class="el" href="a00349_source.html">eventloop.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a93f54abf0f63a1de518ebaafbd3b699a"></a><!-- doxytag: member="qi::operator!=" ref="a93f54abf0f63a1de518ebaafbd3b699a" args="(const AnyIterator &amp;a, const AnyIterator &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00399_source.html#l00060">60</a> of file <a class="el" href="a00399_source.html">anyiterator.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a621564f7183b228b46b58f1569bb563c"></a><!-- doxytag: member="qi::operator!=" ref="a621564f7183b228b46b58f1569bb563c" args="(const AnyValue &amp;a, const AnyValue &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00402_source.html#l00185">185</a> of file <a class="el" href="a00402_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8034f21d05a022058fc33b5d6f544f3c"></a><!-- doxytag: member="qi::operator!=" ref="a8034f21d05a022058fc33b5d6f544f3c" args="(const Url &amp;lhs, const Url &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares the url strings. </p>

<p>Definition at line <a class="el" href="a00443_source.html#l00130">130</a> of file <a class="el" href="a00443_source.html">url.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac398d2fe06ebe5fdef4da056f35be095"></a><!-- doxytag: member="qi::operator!=" ref="ac398d2fe06ebe5fdef4da056f35be095" args="(const Signature &amp;lhs, const Signature &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00390_source.html#l00154">154</a> of file <a class="el" href="a00390_source.html">signature.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef6d91fe199c228cda7583edf00e5363"></a><!-- doxytag: member="qi::operator!=" ref="aef6d91fe199c228cda7583edf00e5363" args="(const AnyReference &amp;a, const AnyReference &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00401_source.html#l00242">242</a> of file <a class="el" href="a00401_source.html">anyreference.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="abe00774a87836a58440771526eb26581"></a><!-- doxytag: member="qi::operator&lt;" ref="abe00774a87836a58440771526eb26581" args="(const TraceAnalyzer::FlowLink &amp;a, const TraceAnalyzer::FlowLink &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const TraceAnalyzer::FlowLink &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TraceAnalyzer::FlowLink &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00423_source.html#l00050">50</a> of file <a class="el" href="a00423_source.html">traceanalyzer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7ecf9e30b3f2341c824fb4bd5493bbf"></a><!-- doxytag: member="qi::operator&lt;" ref="ae7ecf9e30b3f2341c824fb4bd5493bbf" args="(const AnyValue &amp;a, const AnyValue &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less than operator. Will compare the values within the <a class="el" href="a00024.html">AnyValue</a>. </p>

<p>Definition at line <a class="el" href="a00402_source.html#l00220">220</a> of file <a class="el" href="a00402_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="afe13c66dd9a2409ff4535a5673f71885"></a><!-- doxytag: member="qi::operator&lt;" ref="afe13c66dd9a2409ff4535a5673f71885" args="(const MetaObject &amp;a, const MetaObject &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const MetaObject &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MetaObject &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c0458e8f45de0e037c7cb9bfa56b31c"></a><!-- doxytag: member="qi::operator&lt;" ref="a6c0458e8f45de0e037c7cb9bfa56b31c" args="(const AnyReference &amp;a, const AnyReference &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3f4e89c404bfea877211a60561db4f52"></a><!-- doxytag: member="qi::operator==" ref="a3f4e89c404bfea877211a60561db4f52" args="(const AnyIterator &amp;a, const AnyIterator &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyIterator &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00399_source.html#l00055">55</a> of file <a class="el" href="a00399_source.html">anyiterator.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ac9403cd278f0ecd3901d3995f3b713d3"></a><!-- doxytag: member="qi::operator==" ref="ac9403cd278f0ecd3901d3995f3b713d3" args="(const AnyValue &amp;a, const AnyValue &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyValue &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Value equality operator. Will compare the values within. </p>

<p>Definition at line <a class="el" href="a00402_source.html#l00225">225</a> of file <a class="el" href="a00402_source.html">anyvalue.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="ae34013b6e2d0244f6863c17607be74a3"></a><!-- doxytag: member="qi::operator==" ref="ae34013b6e2d0244f6863c17607be74a3" args="(const Url &amp;lhs, const Url &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Url &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares the url strings. </p>

</div>
</div>
<a class="anchor" id="a6df69be73d369666577f9d4b2cd8dd78"></a><!-- doxytag: member="qi::operator==" ref="a6df69be73d369666577f9d4b2cd8dd78" args="(const Signature &amp;lhs, const Signature &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Signature &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa93b0cb5de04863592216daa6888214b"></a><!-- doxytag: member="qi::operator==" ref="aa93b0cb5de04863592216daa6888214b" args="(const AnyReference &amp;a, const AnyReference &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool qi::operator== </td>
          <td>(</td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnyReference &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7c925ffbdf318146bade10e2ef6f64f"></a><!-- doxytag: member="qi::PromiseNoop" ref="ac7c925ffbdf318146bade10e2ef6f64f" args="(const qi::Promise&lt; T &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#ac7c925ffbdf318146bade10e2ef6f64f">qi::PromiseNoop</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00016.html">qi::Promise</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function that does nothing on future cancellation. </p>

<p>Definition at line <a class="el" href="a00352_source.html#l00832">832</a> of file <a class="el" href="a00352_source.html">future_fwd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aceece21123bf061395fb61c01731a274"></a><!-- doxytag: member="qi::propertyAccess" ref="aceece21123bf061395fb61c01731a274" args="(A acc, void *instance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;typename <a class="el" href="a00042.html">detail::Accessor</a>&lt;A&gt;::is_accessor, <a class="el" href="a00257.html">PropertyBase</a>*&gt;::type <a class="el" href="a00359.html#aceece21123bf061395fb61c01731a274">qi::propertyAccess</a> </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00416_source.html#l00170">170</a> of file <a class="el" href="a00416_source.html">objecttypebuilder.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a1f39390146087e0629f56a47773afee0"></a><!-- doxytag: member="qi::registerCppEmbeddedModule" ref="a1f39390146087e0629f56a47773afee0" args="(const std::string &amp;moduleName, boost::function&lt; void(ModuleBuilder *)&gt; fun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00359.html#a1f39390146087e0629f56a47773afee0">qi::registerCppEmbeddedModule</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>moduleName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void(ModuleBuilder *)&gt;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>register a module into the module map </p>

</div>
</div>
<a class="anchor" id="a726e9946485acd3c5125ab71981d964b"></a><!-- doxytag: member="qi::registerModuleFactory" ref="a726e9946485acd3c5125ab71981d964b" args="(const std::string &amp;name, ModuleFactoryFunctor fun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00359.html#a726e9946485acd3c5125ab71981d964b">qi::registerModuleFactory</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModuleFactoryFunctor&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a module factory for a given language </p>

</div>
</div>
<a class="anchor" id="acf8a20b9f03fa67591063d18d0d20a7c"></a><!-- doxytag: member="qi::registerProxy" ref="acf8a20b9f03fa67591063d18d0d20a7c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProxyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00359.html#acf8a20b9f03fa67591063d18d0d20a7c">qi::registerProxy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register <code><a class="el" href="a00258.html">Proxy</a></code> as a proxy class. Required for bound methods to accept a ProxyPtr as argument <a class="el" href="a00258.html">Proxy</a> must be constructible with an AnyObject as argument </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>unused value, present to ease registration at static initialisation </dd></dl>

<p>Definition at line <a class="el" href="a00419_source.html#l00169">169</a> of file <a class="el" href="a00419_source.html">proxyregister.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32994dde8c5e2313e5a50cb83a87e138"></a><!-- doxytag: member="qi::registerProxyInterface" ref="a32994dde8c5e2313e5a50cb83a87e138" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Proxy , typename Interface &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00359.html#a32994dde8c5e2313e5a50cb83a87e138">qi::registerProxyInterface</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register <code><a class="el" href="a00258.html">Proxy</a></code> as a proxy class for interface <code>Interface</code>. Required to allow the typesystem to construct an Object&lt;Interface&gt; from an AnyObject. <a class="el" href="a00258.html">Proxy</a> must be constructible with an AnyObject as argument </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>unused value, present to ease registration at static initialisation </dd></dl>

<p>Definition at line <a class="el" href="a00419_source.html#l00152">152</a> of file <a class="el" href="a00419_source.html">proxyregister.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5acba1383706c293755c20935f7d613"></a><!-- doxytag: member="qi::registerStruct" ref="ae5acba1383706c293755c20935f7d613" args="(TypeInterface *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#ae5acba1383706c293755c20935f7d613">qi::registerStruct</a> </td>
          <td>(</td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register type for signature -&gt; <a class="el" href="a00315.html">TypeInterface</a> factory. </p>

</div>
</div>
<a class="anchor" id="a74b3c262e479a240240bf2ddd3cb0f7e"></a><!-- doxytag: member="qi::registerType" ref="a74b3c262e479a240240bf2ddd3cb0f7e" args="(const std::type_info &amp;typeId, TypeInterface *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00359.html#a74b3c262e479a240240bf2ddd3cb0f7e">qi::registerType</a> </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeInterface *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Runtime Type factory setter. </p>

</div>
</div>
<a class="anchor" id="a167afc34f376286d2e46424ae4941065"></a><!-- doxytag: member="qi::signalAccess" ref="a167afc34f376286d2e46424ae4941065" args="(A acc, void *instance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;typename <a class="el" href="a00042.html">detail::Accessor</a>&lt;A&gt;::is_accessor, <a class="el" href="a00267.html">SignalBase</a>*&gt;::type <a class="el" href="a00359.html#a167afc34f376286d2e46424ae4941065">qi::signalAccess</a> </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00416_source.html#l00162">162</a> of file <a class="el" href="a00416_source.html">objecttypebuilder.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a8199ee4e592ad4e5a704d44eefac588b"></a><!-- doxytag: member="qi::signatureSplit" ref="a8199ee4e592ad4e5a704d44eefac588b" args="(const std::string &amp;fullSignature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; <a class="el" href="a00359.html#a8199ee4e592ad4e5a704d44eefac588b">qi::signatureSplit</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fullSignature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74acfd43dea835f6752dad8fa47cc7f1"></a><!-- doxytag: member="qi::sleepFor" ref="a74acfd43dea835f6752dad8fa47cc7f1" args="(const qi::Duration &amp;d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a74acfd43dea835f6752dad8fa47cc7f1">qi::sleepFor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00359.html#aa5d4c066f262dfde002d18537d30260e">qi::Duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blocks the execution of the current thread for at least <code>d</code>. </p>

</div>
</div>
<a class="anchor" id="a342cbb877923284a84ec54f51a4009c4"></a><!-- doxytag: member="qi::sleepFor" ref="a342cbb877923284a84ec54f51a4009c4" args="(const boost::chrono::duration&lt; Rep, Period &gt; &amp;d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a74acfd43dea835f6752dad8fa47cc7f1">qi::sleepFor</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00348_source.html#l00016">16</a> of file <a class="el" href="a00348_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a25f5e223a90ec2016534ef6d33d9729f"></a><!-- doxytag: member="qi::sleepUntil" ref="a25f5e223a90ec2016534ef6d33d9729f" args="(const SteadyClockTimePoint &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a25f5e223a90ec2016534ef6d33d9729f">qi::sleepUntil</a> </td>
          <td>(</td>
          <td class="paramtype">const SteadyClockTimePoint &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks the execution of the current thread until <code>t</code> has been reached. </p>
<p>This is equivalent to sleep_for(SteadyClockTimePoint::now())</p>
<p>Adjustments of the clock are taken into account. Thus the duration of the block might, but might not, be less or more than t - <a class="el" href="a00332.html#a60887a70861221da7030fca02ce137d0" title="Returns a time_point representing the current value of the clock.">WallClock::now()</a> </p>

</div>
</div>
<a class="anchor" id="a58586cd571c328f307c91f3768d47ed5"></a><!-- doxytag: member="qi::sleepUntil" ref="a58586cd571c328f307c91f3768d47ed5" args="(const boost::chrono::time_point&lt; SteadyClock, Duration &gt; &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a25f5e223a90ec2016534ef6d33d9729f">qi::sleepUntil</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::time_point&lt; SteadyClock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00348_source.html#l00022">22</a> of file <a class="el" href="a00348_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="adf1f0ef331bcf3d99b238e94b17a59ea"></a><!-- doxytag: member="qi::sleepUntil" ref="adf1f0ef331bcf3d99b238e94b17a59ea" args="(const boost::chrono::time_point&lt; WallClock, Duration &gt; &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a25f5e223a90ec2016534ef6d33d9729f">qi::sleepUntil</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::chrono::time_point&lt; WallClock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00348_source.html#l00028">28</a> of file <a class="el" href="a00348_source.html">clock.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a5eeed22e4f35d2e93eac1fec0ff4dd48"></a><!-- doxytag: member="qi::startEventLoop" ref="a5eeed22e4f35d2e93eac1fec0ff4dd48" args="(int nthread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#a5eeed22e4f35d2e93eac1fec0ff4dd48">qi::startEventLoop</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start the eventloop with nthread threads. No-op if already started. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nthread</td><td>Set the minimum number of worker threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84baf7f5923e7dff446646a210cfdbf1"></a><!-- doxytag: member="qi::steadyClockNow" ref="a84baf7f5923e7dff446646a210cfdbf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#ab752bd54724652b6a0b86bd680b434de">SteadyClockTimePoint</a> <a class="el" href="a00359.html#a84baf7f5923e7dff446646a210cfdbf1">qi::steadyClockNow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a time_point representing the current value of the clock. </p>
 
<p>Definition at line <a class="el" href="a00346_source.html#l00164">164</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af55c8cbcb460492f02918d9f5a8cb3be"></a><!-- doxytag: member="qi::testAndSet" ref="af55c8cbcb460492f02918d9f5a8cb3be" args="(long *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="a00359.html#af55c8cbcb460492f02918d9f5a8cb3be">qi::testAndSet</a> </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cross-platform implementation of atomic Test-And-Set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>pointer to the value to test and set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true (1) if cond is 0, false (0) otherwise. </dd></dl>

<p>Definition at line <a class="el" href="a00343_source.html#l00035">35</a> of file <a class="el" href="a00343_source.html">atomic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af45a0666a72fce61092131ac4318cc90"></a><!-- doxytag: member="qi::tr" ref="af45a0666a72fce61092131ac4318cc90" args="(const std::string &amp;msg, const std::string &amp;domain=&quot;&quot;, const std::string &amp;locale=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="a00359.html#af45a0666a72fce61092131ac4318cc90">qi::tr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>domain</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locale</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Translate a message. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to translate </td></tr>
    <tr><td class="paramname">domain</td><td>Domain name </td></tr>
    <tr><td class="paramname">locale</td><td>Locale name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The translated message </dd></dl>
 
</div>
</div>
<a class="anchor" id="af68a5d1f435c85272a104accccbc3d8e"></a><!-- doxytag: member="qi::track" ref="af68a5d1f435c85272a104accccbc3d8e" args="(const boost::function&lt; F &gt; &amp;f, const ARG0 &amp;arg0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ARG0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt; F &gt; <a class="el" href="a00359.html#af68a5d1f435c85272a104accccbc3d8e">qi::track</a> </td>
          <td>(</td>
          <td class="paramtype">const boost::function&lt; F &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ARG0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="a00281.html" title="Object tracking by blocking destruction while shared pointers are present.">Trackable</a> instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a function that, when called:<ul>
<li>If lock can be acquired, calls f</li>
<li>Else throws <a class="el" href="a00252.html">qi::PointerLockException</a> </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a00355_source.html#l00193">193</a> of file <a class="el" href="a00355_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="af41c3c455c1fc41a160ea836c10947e2"></a><!-- doxytag: member="qi::trackWithFallback" ref="af41c3c455c1fc41a160ea836c10947e2" args="(boost::function&lt; void()&gt; onFail, const boost::function&lt; F &gt; &amp;f, const ARG0 &amp;arg0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename ARG0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt; F &gt; <a class="el" href="a00359.html#af41c3c455c1fc41a160ea836c10947e2">qi::trackWithFallback</a> </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>onFail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::function&lt; F &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ARG0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrap given function f with a tracking check on arg0, which must be a weak pointer or a <a class="el" href="a00281.html" title="Object tracking by blocking destruction while shared pointers are present.">Trackable</a> instance. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a function that, when called:<ul>
<li>If lock can be acquired, calls f</li>
<li>Else calls onFail </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="a00355_source.html#l00199">199</a> of file <a class="el" href="a00355_source.html">trackable.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa46c718a20275ea16ae730bd2e2b487a"></a><!-- doxytag: member="qi::typeDispatch" ref="aa46c718a20275ea16ae730bd2e2b487a" args="(const TypeDispatcher &amp;vv, AnyReference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeDispatcher &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TypeDispatcher&amp; <a class="el" href="a00359.html#aa46c718a20275ea16ae730bd2e2b487a">qi::typeDispatch</a> </td>
          <td>(</td>
          <td class="paramtype">const TypeDispatcher &amp;&#160;</td>
          <td class="paramname"><em>vv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyReference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="a00426_source.html#l00013">13</a> of file <a class="el" href="a00426_source.html">typedispatcher.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aac32d67b110554995783ad4bd9994229"></a><!-- doxytag: member="qi::typeDispatch" ref="aac32d67b110554995783ad4bd9994229" args="(const Dispatcher &amp;dispatcher, AnyReference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dispatcher &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Dispatcher&amp; <a class="el" href="a00359.html#aa46c718a20275ea16ae730bd2e2b487a">qi::typeDispatch</a> </td>
          <td>(</td>
          <td class="paramtype">const Dispatcher &amp;&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AnyReference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke one of the visitor functions in dispatcher based on kind(). Dispatcher must implement TypeDispatcher. </p>

</div>
</div>
<a class="anchor" id="a45c4fec4058dee00453ef20d1c544eec"></a><!-- doxytag: member="qi::typeOf" ref="a45c4fec4058dee00453ef20d1c544eec" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a> * <a class="el" href="a00359.html#a45c4fec4058dee00453ef20d1c544eec">qi::typeOf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get type from a type. Will return a static TypeImpl&lt;T&gt; if T is not registered </p>

<p>Definition at line <a class="el" href="a00425_source.html#l00091">91</a> of file <a class="el" href="a00425_source.html">type.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa42acc117e914a07695eb02cd0a13aeb"></a><!-- doxytag: member="qi::typeOf" ref="aa42acc117e914a07695eb02cd0a13aeb" args="(const T &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00315.html">TypeInterface</a>* <a class="el" href="a00359.html#a45c4fec4058dee00453ef20d1c544eec">qi::typeOf</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get type from a value. No need to delete the result. </p>

<p>Definition at line <a class="el" href="a00428_source.html#l00191">191</a> of file <a class="el" href="a00428_source.html">typeinterface.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8a4809b2a654f168ec5c75609ebc04c1"></a><!-- doxytag: member="qi::unicodeFacet" ref="a8a4809b2a654f168ec5c75609ebc04c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00359.html#ad285b93d0b3fd990de2df5bb7ea893bd">codecvt_type</a>&amp; <a class="el" href="a00359.html#a8a4809b2a654f168ec5c75609ebc04c1">qi::unicodeFacet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UTF-8 facet object getter. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>UTF-8 implementation for std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;</dd></dl>
<p>Return a facet object that can be used by stl (iostream, locale, ...) and std::locale compliant library like boost::filesystem.</p>
<p>This class allow conversion between UTF-8 (char) and UTF-16/UTF-32 (wchar). </p>

</div>
</div>
<a class="anchor" id="ae3afa109040d75d6c2dabcb08001e9fe"></a><!-- doxytag: member="qi::waitForAll" ref="ae3afa109040d75d6c2dabcb08001e9fe" args="(std::vector&lt; Future&lt; T &gt; &gt; &amp;vect)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00359.html#ae3afa109040d75d6c2dabcb08001e9fe">qi::waitForAll</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Future&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to wait on a vector of futures. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>The vector of futures to wait on.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">
   * This function will wait on all the futures of the given vector and return
   * when they have all been set, either with an error or a valid value.
   * </pre></div> 
<p>Definition at line <a class="el" href="a00351_source.html#l00297">297</a> of file <a class="el" href="a00351_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="aa071177a4b92a882b1d5359cddc17a5e"></a><!-- doxytag: member="qi::waitForFirst" ref="aa071177a4b92a882b1d5359cddc17a5e" args="(std::vector&lt; Future&lt; T &gt; &gt; &amp;vect)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00206.html">qi::FutureSync</a>&lt; <a class="el" href="a00010.html">qi::Future</a>&lt; T &gt; &gt; <a class="el" href="a00359.html#aa071177a4b92a882b1d5359cddc17a5e">qi::waitForFirst</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Future&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function to wait for the first valid future. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>The vector of futures to wait on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first valid future, or an error.</dd></dl>
<div class="fragment"><pre class="fragment">
   * This function will wait on all the futures of the vector. It returns the
   * first valid future that returns. If no future is valid, a future set with
   * an error is returned.
   * </pre></div> 
<p>Definition at line <a class="el" href="a00351_source.html#l00308">308</a> of file <a class="el" href="a00351_source.html">future.hxx</a>.</p>

</div>
</div>
<a class="anchor" id="a04b07a98ec099f7d8e14637d2d7dc531"></a><!-- doxytag: member="qi::wallClockNow" ref="a04b07a98ec099f7d8e14637d2d7dc531" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00359.html#a739c9431170590d38d2bde9cf595d474">WallClockTimePoint</a> <a class="el" href="a00359.html#a04b07a98ec099f7d8e14637d2d7dc531">qi::wallClockNow</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a time_point representing the current value of the clock. </p>
 
<p>Definition at line <a class="el" href="a00346_source.html#l00169">169</a> of file <a class="el" href="a00346_source.html">clock.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Copyright Aldebaran Robotics
<!-- Generated on Wed Oct 29 2014 16:04:34 for libqi-api by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1</small></address> -->

</body>
</html>
