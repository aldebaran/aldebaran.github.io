<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>/home/opennao/work/master/sdk/libqi/qi/type/detail/anyfunctionfactory.hxx Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>


<div id="top"><!-- do not remove this div! -->
<div class="related">
  <ul>
    <!-- <li style="margin-right: 10px" class="right"> -->
    <!--   <a accesskey="I" title="General Index" href="genindex.html">index</a> -->
    <!-- </li> -->
    <!-- <li class="right"> -->
    <!--   <a accesskey="N" title="Whatâ€™s new?" href="news/whatsnew/index.html">next</a> | -->
    <!-- </li> -->
    <li><a href="../../index.html">Aldebaran documentation</a> |</li>
    <li><a href="../../ref/cpp-api.html">C++ Libraries</a> |</li>
    <li><a href="index.html">index</a></li>
  </ul>
</div>


<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libqi-api
   &#160;<span id="projectnumber">2.2.0.55</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/opennao/work/master/sdk/libqi/qi/type/detail/anyfunctionfactory.hxx</div>  </div>
</div><!--header-->
<div class="contents">
<a href="a00397.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#pragma once</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00003"></a>00003 <span class="comment">**  Copyright (C) 2013 Aldebaran Robotics</span>
<a name="l00004"></a>00004 <span class="comment">**  See COPYING for the license</span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#ifndef _QITYPE_DETAILS_ANYFUNCTIONFACTORY_HXX_</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#define _QITYPE_DETAILS_ANYFUNCTIONFACTORY_HXX_</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;boost/mpl/for_each.hpp&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;boost/mpl/transform_view.hpp&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;boost/mpl/find_if.hpp&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;boost/mpl/vector.hpp&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;boost/mpl/pop_front.hpp&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;boost/mpl/at.hpp&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/mpl/placeholders.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;boost/mpl/max_element.hpp&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;boost/mpl/transform.hpp&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;boost/type_traits/remove_reference.hpp&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;boost/type_traits/add_pointer.hpp&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;boost/type_traits/remove_const.hpp&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;boost/type_traits/remove_pointer.hpp&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;boost/type_traits/is_member_function_pointer.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;boost/function_types/function_type.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/function_types/function_arity.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/function_types/function_pointer.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/function_types/member_function_pointer.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/function_types/result_type.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/function_types/parameter_types.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;boost/any.hpp&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;boost/thread/mutex.hpp&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="a00343.html">qi/atomic.hpp</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="a00338.html">qi/anyvalue.hpp</a>&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">namespace </span>qi
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038   <span class="keyword">namespace </span>detail
<a name="l00039"></a>00039   {
<a name="l00040"></a>00040     <span class="comment">/* General idea: code generated to make a function call taking a</span>
<a name="l00041"></a>00041 <span class="comment">     * void*, long, or long&amp; is the same.</span>
<a name="l00042"></a>00042 <span class="comment">     * So we reduce the function types for which we effectively implement</span>
<a name="l00043"></a>00043 <span class="comment">     * call, and bounce the equivalent functions to it.</span>
<a name="l00044"></a>00044 <span class="comment">     */</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     <span class="comment">/* ASSERTS</span>
<a name="l00047"></a>00047 <span class="comment">     * We make some asumptions for this code to work. Failure on any of</span>
<a name="l00048"></a>00048 <span class="comment">     * those asumptions will *not* be detected and will cause undefined behavior.</span>
<a name="l00049"></a>00049 <span class="comment">     * - typesystem Storage for pointer types is by-value, and by-pointer for everything else</span>
<a name="l00050"></a>00050 <span class="comment">     * - compiler-generated code is the same when calling a function:</span>
<a name="l00051"></a>00051 <span class="comment">     *     - with argument T and EqType&lt;T&gt;::type</span>
<a name="l00052"></a>00052 <span class="comment">     *     - with return type T and EqType&lt;T&gt;::rType</span>
<a name="l00053"></a>00053 <span class="comment">     *     - with all pointer types and all reference types for argument/return type</span>
<a name="l00054"></a>00054 <span class="comment">     */</span>
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="a00076.html">00056</a>     <span class="keyword">class </span><a class="code" href="a00076.html">Class</a>{}; <span class="comment">// dummy class placeholder</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058     <span class="comment">/* For each type, get equivalent type, and if it is a reference</span>
<a name="l00059"></a>00059 <span class="comment">     * Equivalent type is a type for which when types are substituted in a</span>
<a name="l00060"></a>00060 <span class="comment">     * function call, compiler-generated code is the same.</span>
<a name="l00061"></a>00061 <span class="comment">     * *WARNING* some magic occurs for return type, so have a separate rule</span>
<a name="l00062"></a>00062 <span class="comment">     * which matches less stuffs for it.</span>
<a name="l00063"></a>00063 <span class="comment">     */</span>
<a name="l00064"></a>00064     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">bool</span> isWordSize&gt;
<a name="l00065"></a><a class="code" href="a00009.html">00065</a>     <span class="keyword">struct </span><a class="code" href="a00009.html">EqTypeBase</a>
<a name="l00066"></a>00066     {
<a name="l00067"></a><a class="code" href="a00009.html#aa544966d4c97c56f7f8c5f77464c3116">00067</a>       <span class="keyword">typedef</span> T <a class="code" href="a00009.html#aa544966d4c97c56f7f8c5f77464c3116">type</a>;
<a name="l00068"></a><a class="code" href="a00009.html#ab34849338d12972e2d76330ac8e6c566">00068</a>       <span class="keyword">typedef</span> T <a class="code" href="a00009.html#ab34849338d12972e2d76330ac8e6c566">rType</a>;
<a name="l00069"></a><a class="code" href="a00009.html#a0b206bf97365e3bb4af9194e7ead2afb">00069</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::is_reference&lt;T&gt;::type <a class="code" href="a00009.html#a0b206bf97365e3bb4af9194e7ead2afb">isReference</a>;
<a name="l00070"></a><a class="code" href="a00009.html#ad322eba1d46e538c899228617f8c46ad">00070</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="a00009.html#ad322eba1d46e538c899228617f8c46ad">dbgTag</a> = 0;
<a name="l00071"></a>00071     };
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00074"></a><a class="code" href="a00090.html">00074</a>     <span class="keyword">struct </span><a class="code" href="a00009.html">EqTypeBase</a>&lt;T, true&gt;
<a name="l00075"></a>00075     {
<a name="l00076"></a><a class="code" href="a00090.html#a32b783762db1d18257262c2c9cfa7c1a">00076</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::if_&lt;typename boost::is_fundamental&lt;T&gt;::type, <span class="keywordtype">void</span>*, T&gt;<a class="code" href="a00090.html#a32b783762db1d18257262c2c9cfa7c1a">::type</a> <a class="code" href="a00090.html#a32b783762db1d18257262c2c9cfa7c1a">type</a>;
<a name="l00077"></a><a class="code" href="a00090.html#aacc74f4caa9438e3a3b5708b43f63767">00077</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::if_&lt;typename boost::is_fundamental&lt;T&gt;::type, <span class="keywordtype">void</span>*, T&gt;<a class="code" href="a00090.html#a32b783762db1d18257262c2c9cfa7c1a">::type</a> <a class="code" href="a00090.html#aacc74f4caa9438e3a3b5708b43f63767">rType</a>;
<a name="l00078"></a><a class="code" href="a00090.html#ae73bd7634c198ac3e58e33756856a2b3">00078</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::is_reference&lt;T&gt;::type <a class="code" href="a00090.html#ae73bd7634c198ac3e58e33756856a2b3">isReference</a>;
<a name="l00079"></a><a class="code" href="a00090.html#a642615d490e11752ea4751525751e258">00079</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="a00009.html#ad322eba1d46e538c899228617f8c46ad">dbgTag</a> = 1;
<a name="l00080"></a>00080     };
<a name="l00081"></a>00081 
<a name="l00082"></a>00082     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00083"></a><a class="code" href="a00082.html">00083</a>     <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>: <span class="keyword">public</span> <a class="code" href="a00009.html">EqTypeBase</a>&lt;T, sizeof(T) == sizeof(void*)&gt;
<a name="l00084"></a>00084     {
<a name="l00085"></a>00085     };
<a name="l00086"></a>00086 
<a name="l00087"></a><a class="code" href="a00089.html">00087</a>     <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>&lt;void&gt;
<a name="l00088"></a>00088     {
<a name="l00089"></a><a class="code" href="a00089.html#a914892d27eef7fb094dbc5f42a939465">00089</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span> <a class="code" href="a00089.html#a914892d27eef7fb094dbc5f42a939465">type</a>;
<a name="l00090"></a><a class="code" href="a00089.html#afd8f000263d339771d820c3db3c0ffce">00090</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="a00089.html#afd8f000263d339771d820c3db3c0ffce">rType</a>;
<a name="l00091"></a><a class="code" href="a00089.html#a071e0a6c0d5d6c9893fd46a2ff5ff0a3">00091</a>       <span class="keyword">typedef</span> boost::false_type <a class="code" href="a00089.html#a071e0a6c0d5d6c9893fd46a2ff5ff0a3">isReference</a>;
<a name="l00092"></a>00092     };
<a name="l00093"></a>00093 
<a name="l00094"></a><a class="code" href="a00084.html">00094</a>     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>&lt;double&gt;
<a name="l00095"></a>00095     {
<a name="l00096"></a><a class="code" href="a00084.html#a6552cb7aafd5f23ac5eec74ba0ffa29c">00096</a>       <span class="keyword">typedef</span> <span class="keywordtype">double</span> <a class="code" href="a00084.html#a6552cb7aafd5f23ac5eec74ba0ffa29c">type</a>;
<a name="l00097"></a><a class="code" href="a00084.html#af47b9b23fb087cc5f1fc757689cd7c7c">00097</a>       <span class="keyword">typedef</span> <span class="keywordtype">double</span> <a class="code" href="a00084.html#af47b9b23fb087cc5f1fc757689cd7c7c">rType</a>;
<a name="l00098"></a><a class="code" href="a00084.html#a493ae3a6056e93739888a840a9dd8bb0">00098</a>       <span class="keyword">typedef</span> boost::false_type <a class="code" href="a00084.html#a493ae3a6056e93739888a840a9dd8bb0">isReference</a>;
<a name="l00099"></a>00099     };
<a name="l00100"></a>00100 
<a name="l00101"></a><a class="code" href="a00085.html">00101</a>     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>&lt;float&gt;
<a name="l00102"></a>00102     {
<a name="l00103"></a><a class="code" href="a00085.html#a5e5fe54fb0831198f0ccd8fc3e0fcc53">00103</a>       <span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="a00085.html#a5e5fe54fb0831198f0ccd8fc3e0fcc53">type</a>;
<a name="l00104"></a><a class="code" href="a00085.html#adda2a7e3ca50a7d56f7d9ae0a376fae6">00104</a>       <span class="keyword">typedef</span> <span class="keywordtype">float</span> <a class="code" href="a00085.html#adda2a7e3ca50a7d56f7d9ae0a376fae6">rType</a>;
<a name="l00105"></a><a class="code" href="a00085.html#a9948648f6efdb05f573cf1e376682366">00105</a>       <span class="keyword">typedef</span> boost::false_type <a class="code" href="a00085.html#a9948648f6efdb05f573cf1e376682366">isReference</a>;
<a name="l00106"></a>00106     };
<a name="l00107"></a>00107 
<a name="l00108"></a><a class="code" href="a00083.html">00108</a>     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>&lt;bool&gt;
<a name="l00109"></a>00109     {
<a name="l00110"></a><a class="code" href="a00083.html#a10155a454e064b49d36e9bada6347f35">00110</a>       <span class="keyword">typedef</span> <span class="keywordtype">bool</span> <a class="code" href="a00083.html#a10155a454e064b49d36e9bada6347f35">type</a>;
<a name="l00111"></a><a class="code" href="a00083.html#a86f0101c6a1ad623f2c61a6f805cda44">00111</a>       <span class="keyword">typedef</span> <span class="keywordtype">bool</span> <a class="code" href="a00083.html#a86f0101c6a1ad623f2c61a6f805cda44">rType</a>;
<a name="l00112"></a><a class="code" href="a00083.html#aed81535b0e0d8aec1239b418959485bb">00112</a>       <span class="keyword">typedef</span> boost::false_type <a class="code" href="a00083.html#aed81535b0e0d8aec1239b418959485bb">isReference</a>;
<a name="l00113"></a>00113     };
<a name="l00114"></a>00114 
<a name="l00115"></a><a class="code" href="a00086.html">00115</a>     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>&lt;T&amp;&gt;
<a name="l00116"></a>00116     {
<a name="l00117"></a><a class="code" href="a00086.html#af118d9df512facc1db8e2d11fa0771b5">00117</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="a00086.html#af118d9df512facc1db8e2d11fa0771b5">type</a>;
<a name="l00118"></a><a class="code" href="a00086.html#af6e6bd22dd5a69a1386e8ac84ff9cd18">00118</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="a00086.html#af6e6bd22dd5a69a1386e8ac84ff9cd18">rType</a>;
<a name="l00119"></a><a class="code" href="a00086.html#a775d13428b3577441eb1007c7d407347">00119</a>       <span class="keyword">typedef</span> boost::true_type <a class="code" href="a00086.html#a775d13428b3577441eb1007c7d407347">isReference</a>;
<a name="l00120"></a><a class="code" href="a00086.html#a0518ea6dd3b1503cdee99fac2dbeba6b">00120</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dbgTag = 2;
<a name="l00121"></a>00121     };
<a name="l00122"></a>00122 
<a name="l00123"></a><a class="code" href="a00088.html">00123</a>     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>&lt;T const &amp;&gt;
<a name="l00124"></a>00124     {
<a name="l00125"></a><a class="code" href="a00088.html#a52669a9bb374b24053fa66ef9dca7592">00125</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="a00088.html#a52669a9bb374b24053fa66ef9dca7592">type</a>;
<a name="l00126"></a><a class="code" href="a00088.html#a4846aa14c40e0f7ba3ad479e99b517d7">00126</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="a00088.html#a4846aa14c40e0f7ba3ad479e99b517d7">rType</a>;
<a name="l00127"></a><a class="code" href="a00088.html#a13e03033802971140491589f2d6f41b3">00127</a>       <span class="keyword">typedef</span> boost::true_type <a class="code" href="a00088.html#a13e03033802971140491589f2d6f41b3">isReference</a>;
<a name="l00128"></a><a class="code" href="a00088.html#ae026923b4f99ffcdac26d95d2ab8616f">00128</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dbgTag = 3;
<a name="l00129"></a>00129     };
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="comment">// HACK: mark pointer as references, because typesystem transmit them</span>
<a name="l00132"></a>00132     <span class="comment">// by-value</span>
<a name="l00133"></a>00133     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00134"></a><a class="code" href="a00087.html">00134</a>     <span class="keyword">struct </span><a class="code" href="a00082.html">EqType</a>&lt;T *&gt;
<a name="l00135"></a>00135     {
<a name="l00136"></a><a class="code" href="a00087.html#a72ec2711401cf8e778393380d5112565">00136</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="a00087.html#a72ec2711401cf8e778393380d5112565">type</a>;
<a name="l00137"></a><a class="code" href="a00087.html#a401d4b43227299668c3e53e1f4d03fd8">00137</a>       <span class="keyword">typedef</span> <span class="keywordtype">void</span>* <a class="code" href="a00087.html#a401d4b43227299668c3e53e1f4d03fd8">rType</a>;
<a name="l00138"></a><a class="code" href="a00087.html#ab67f37cdc40543f1a5c1e7226830627d">00138</a>       <span class="keyword">typedef</span> boost::true_type <a class="code" href="a00087.html#ab67f37cdc40543f1a5c1e7226830627d">isReference</a>;
<a name="l00139"></a><a class="code" href="a00087.html#a75a85b4756d367044d5381314537a925">00139</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> dbgTag = 4;
<a name="l00140"></a>00140     };
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     <span class="comment">// helper to compute a reference mask iterating through a mpl sequence</span>
<a name="l00143"></a>00143     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> S, <span class="keyword">typename</span> I, <span class="keywordtype">int</span> p&gt;
<a name="l00144"></a><a class="code" href="a00136.html">00144</a>     <span class="keyword">struct </span><a class="code" href="a00136.html">RefMasqBuilderHelper</a>
<a name="l00145"></a>00145     {
<a name="l00146"></a><a class="code" href="a00136.html#a79d2996245e3c655dae8e36a71f401d7">00146</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::deref&lt;I&gt;::type <a class="code" href="a00136.html#a79d2996245e3c655dae8e36a71f401d7">type</a>;
<a name="l00147"></a><a class="code" href="a00136.html#a46099a2de33153262a94320cebb662dd">00147</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="a00136.html#a46099a2de33153262a94320cebb662dd">isRef</a> = <a class="code" href="a00082.html">EqType&lt;type&gt;::isReference::value</a>;
<a name="l00148"></a><a class="code" href="a00136.html#a37931b3f50b2b6fc168fba4c56c17527">00148</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00136.html#a37931b3f50b2b6fc168fba4c56c17527">vSelf</a> = <a class="code" href="a00136.html#a46099a2de33153262a94320cebb662dd">isRef</a> &lt;&lt; p;
<a name="l00149"></a><a class="code" href="a00136.html#a221dcdafa54118a12d17c56b64bbdbe5">00149</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00136.html#a221dcdafa54118a12d17c56b64bbdbe5">val</a> = <a class="code" href="a00136.html#a37931b3f50b2b6fc168fba4c56c17527">vSelf</a> + <a class="code" href="a00136.html">RefMasqBuilderHelper</a>&lt;S,
<a name="l00150"></a>00150       <span class="keyword">typename</span> boost::mpl::next&lt;I&gt;::type, p+1&gt;<a class="code" href="a00136.html#a221dcdafa54118a12d17c56b64bbdbe5">::val</a>;
<a name="l00151"></a>00151     };
<a name="l00152"></a>00152 
<a name="l00153"></a>00153     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> S, <span class="keywordtype">int</span> p&gt;
<a name="l00154"></a><a class="code" href="a00137.html">00154</a>     <span class="keyword">struct </span><a class="code" href="a00136.html">RefMasqBuilderHelper</a>&lt;S, typename boost::mpl::end&lt;S&gt;::type, p&gt;
<a name="l00155"></a>00155     {
<a name="l00156"></a><a class="code" href="a00137.html#adc6c67d0e3f478dbe174eefc13bb2d81">00156</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00136.html#a221dcdafa54118a12d17c56b64bbdbe5">val</a> = 0;
<a name="l00157"></a>00157     };
<a name="l00158"></a>00158 
<a name="l00159"></a>00159     <span class="comment">/* Equivalent function info for function type F</span>
<a name="l00160"></a>00160 <span class="comment">   *</span>
<a name="l00161"></a>00161 <span class="comment">   */</span>
<a name="l00162"></a><a class="code" href="a00080.html">00162</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt; <span class="keyword">struct </span><a class="code" href="a00080.html">EqFunctionBare</a>
<a name="l00163"></a>00163     {
<a name="l00164"></a><a class="code" href="a00080.html#ae44c68a520276d22837b696a235bf290">00164</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::components&lt;F&gt;::type <a class="code" href="a00080.html#ae44c68a520276d22837b696a235bf290">Components</a>;
<a name="l00165"></a>00165 
<a name="l00166"></a><a class="code" href="a00080.html#a40db11524a45999dbbc703aac428a153">00166</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::parameter_types&lt;F&gt;::type <a class="code" href="a00080.html#a40db11524a45999dbbc703aac428a153">Arguments</a>;
<a name="l00167"></a><a class="code" href="a00080.html#ab0669847fc08ca39ac75909de915435b">00167</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;F&gt;::type <a class="code" href="a00080.html#ab0669847fc08ca39ac75909de915435b">Result</a>;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169       <span class="comment">// need to handle result type separately</span>
<a name="l00170"></a>00170       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::transform&lt;<a class="code" href="a00080.html#a40db11524a45999dbbc703aac428a153">Arguments</a>,
<a name="l00171"></a><a class="code" href="a00080.html#ad7a28bffe82d41dd293ac1b28df97087">00171</a>       <a class="code" href="a00082.html">EqType&lt;boost::mpl::_1&gt;</a> &gt;<a class="code" href="a00080.html#a41e28814af3bc5a64ec69806271deabc">::type</a> <a class="code" href="a00080.html#ad7a28bffe82d41dd293ac1b28df97087">EqArguments</a>;
<a name="l00172"></a><a class="code" href="a00080.html#a86a2b642ce88e6e05477e95b56bbd1b0">00172</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00009.html#ab34849338d12972e2d76330ac8e6c566">EqType&lt;Result&gt;::rType</a> <a class="code" href="a00080.html#a86a2b642ce88e6e05477e95b56bbd1b0">EqResult</a>;
<a name="l00173"></a><a class="code" href="a00080.html#a240fc6a7bb67e8807278b8a9ea557317">00173</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::push_front&lt;EqArguments, EqResult&gt;::type <a class="code" href="a00080.html#a240fc6a7bb67e8807278b8a9ea557317">EqComponents</a>;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175       <span class="comment">// Bit b is set if argument index b+1 (0=return type) is a reference.</span>
<a name="l00176"></a><a class="code" href="a00080.html#ae974e5f752b674a9f258c44e28b938e3">00176</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00080.html#ae974e5f752b674a9f258c44e28b938e3">refMask</a> = <a class="code" href="a00136.html">RefMasqBuilderHelper</a>&lt;<a class="code" href="a00080.html#ae44c68a520276d22837b696a235bf290">Components</a>,
<a name="l00177"></a>00177       <span class="keyword">typename</span> boost::mpl::begin&lt;Components&gt;::type, 0&gt;::val;
<a name="l00178"></a><a class="code" href="a00080.html#a41e28814af3bc5a64ec69806271deabc">00178</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::function_type&lt;EqComponents&gt;::type <a class="code" href="a00080.html#a41e28814af3bc5a64ec69806271deabc">type</a>;
<a name="l00179"></a>00179     };
<a name="l00180"></a>00180 
<a name="l00181"></a><a class="code" href="a00081.html">00181</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt; <span class="keyword">struct </span><a class="code" href="a00081.html">EqMemberFunction</a>
<a name="l00182"></a>00182     {
<a name="l00183"></a><a class="code" href="a00081.html#a4844be754a569fd302f80856d032c59a">00183</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::components&lt;F&gt;::type <a class="code" href="a00081.html#a4844be754a569fd302f80856d032c59a">Components</a>;
<a name="l00184"></a>00184       <span class="comment">// we need to handle object type and return type separately</span>
<a name="l00185"></a>00185       <span class="comment">// arguments with object</span>
<a name="l00186"></a><a class="code" href="a00081.html#a5192e3d286c2e514bbe51906fcfaaf5b">00186</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::parameter_types&lt;F&gt;::type <a class="code" href="a00081.html#a5192e3d286c2e514bbe51906fcfaaf5b">MethodArguments</a>;
<a name="l00187"></a>00187       <span class="comment">// arguments without object</span>
<a name="l00188"></a><a class="code" href="a00081.html#a21c3a7b2c4681b2087555422a26e0f80">00188</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::pop_front&lt;MethodArguments&gt;::type <a class="code" href="a00081.html#a21c3a7b2c4681b2087555422a26e0f80">Arguments</a>;
<a name="l00189"></a>00189       <span class="comment">// return type</span>
<a name="l00190"></a><a class="code" href="a00081.html#a8ccaad8fb8cb08e8d08788e37502136a">00190</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;F&gt;::type <a class="code" href="a00081.html#a8ccaad8fb8cb08e8d08788e37502136a">Result</a>;
<a name="l00191"></a>00191       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::transform&lt;<a class="code" href="a00081.html#a21c3a7b2c4681b2087555422a26e0f80">Arguments</a>,
<a name="l00192"></a><a class="code" href="a00081.html#aac172fcc5e34024f2d8057b786444146">00192</a>       <a class="code" href="a00082.html">EqType&lt;boost::mpl::_1&gt;</a> &gt;<a class="code" href="a00081.html#a21fa6ced8c5066529bc17e8547a4b615">::type</a> <a class="code" href="a00081.html#aac172fcc5e34024f2d8057b786444146">EqArguments</a>;
<a name="l00193"></a><a class="code" href="a00081.html#a51fbeab5fe4b959ce135cab690235a2a">00193</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00009.html#ab34849338d12972e2d76330ac8e6c566">EqType&lt;Result&gt;::rType</a> <a class="code" href="a00081.html#a51fbeab5fe4b959ce135cab690235a2a">EqResult</a>;
<a name="l00194"></a>00194       <span class="comment">// push equivalent object type</span>
<a name="l00195"></a><a class="code" href="a00081.html#a974e5e3bd3937483833d45d833ff1432">00195</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::push_front&lt;EqArguments, detail::Class&amp;&gt;::type <a class="code" href="a00081.html#a974e5e3bd3937483833d45d833ff1432">EqComponentsInt</a>;
<a name="l00196"></a><a class="code" href="a00081.html#aa1cc9410a951f0d45ebef640c1285fe3">00196</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::push_front&lt;EqComponentsInt, EqResult&gt;::type <a class="code" href="a00081.html#aa1cc9410a951f0d45ebef640c1285fe3">EqComponents</a>;
<a name="l00197"></a><a class="code" href="a00081.html#a21fa6ced8c5066529bc17e8547a4b615">00197</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::member_function_pointer&lt;EqComponents&gt;::type <a class="code" href="a00081.html#a21fa6ced8c5066529bc17e8547a4b615">type</a>;
<a name="l00198"></a><a class="code" href="a00081.html#a196bdf0c371b3b7dd5465aa4c78c22ba">00198</a>       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00081.html#a196bdf0c371b3b7dd5465aa4c78c22ba">refMask</a> = <a class="code" href="a00136.html">RefMasqBuilderHelper</a>&lt;<a class="code" href="a00081.html#a4844be754a569fd302f80856d032c59a">Components</a>,
<a name="l00199"></a>00199       <span class="keyword">typename</span> boost::mpl::begin&lt;Components&gt;::type, 0&gt;::val;
<a name="l00200"></a>00200     };
<a name="l00201"></a>00201 
<a name="l00202"></a>00202     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;
<a name="l00203"></a><a class="code" href="a00079.html">00203</a>     <span class="keyword">struct </span><a class="code" href="a00079.html">EqFunction</a>:
<a name="l00204"></a>00204         <span class="keyword">public</span> boost::mpl::if_&lt;typename boost::is_member_function_pointer&lt;F&gt;::type,
<a name="l00205"></a>00205                                EqMemberFunction&lt;F&gt;,
<a name="l00206"></a>00206                                EqFunctionBare&lt;F&gt; &gt;::type
<a name="l00207"></a>00207     {};
<a name="l00208"></a>00208     <span class="comment">/* args[i] is a pointer to an element of expected type DROPPING ref</span>
<a name="l00209"></a>00209 <span class="comment">     * we will make the call by dereferencing all args, so we must add</span>
<a name="l00210"></a>00210 <span class="comment">     * one layer of pointer to effective refs</span>
<a name="l00211"></a>00211 <span class="comment">     *</span>
<a name="l00212"></a>00212 <span class="comment">     */</span>
<a name="l00213"></a><a class="code" href="a00450.html#a8a86eb8570a7c7aad7d02732daf90387">00213</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00450.html#a8a86eb8570a7c7aad7d02732daf90387">transformRef</a>(<span class="keywordtype">void</span>** args, <span class="keywordtype">void</span>** out, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> refMask)
<a name="l00214"></a>00214     {
<a name="l00215"></a>00215       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;sz; ++i)
<a name="l00216"></a>00216       {
<a name="l00217"></a>00217         <span class="keywordflow">if</span> (refMask &amp; (1 &lt;&lt; (i+1))) <span class="comment">// bit 0 is for return type</span>
<a name="l00218"></a>00218           out[i] = &amp;args[i];
<a name="l00219"></a>00219         <span class="keywordflow">else</span>
<a name="l00220"></a>00220           out[i] = args[i];
<a name="l00221"></a>00221       }
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223 
<a name="l00234"></a><a class="code" href="a00055.html">00234</a>     <span class="keyword">class </span><a class="code" href="a00055.html">AnyReferenceCopy</a>: <span class="keyword">public</span> <a class="code" href="a00023.html">AnyReference</a>
<a name="l00235"></a>00235     {
<a name="l00236"></a>00236     <span class="keyword">public</span>:
<a name="l00237"></a><a class="code" href="a00055.html#a51e8e8de32d0a437c3206057e805af84">00237</a>       <a class="code" href="a00055.html">AnyReferenceCopy</a> &amp;<a class="code" href="a00055.html#a51e8e8de32d0a437c3206057e805af84">operator()</a>() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00238"></a>00238     };
<a name="l00239"></a>00239 
<a name="l00240"></a><a class="code" href="a00450.html#a00f48a40992a9368b3f9d08b443151ad">00240</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="a00450.html#a00f48a40992a9368b3f9d08b443151ad">operator,</a>(<a class="code" href="a00055.html">AnyReferenceCopy</a>&amp; g, <span class="keyword">const</span> T&amp; any)
<a name="l00241"></a>00241     {
<a name="l00242"></a>00242       *(<a class="code" href="a00023.html">AnyReference</a>*)&amp;g = <a class="code" href="a00054.html#adab823dcef7ded31c6c21d0269de6266">AnyReference::from</a>(any).<a class="code" href="a00054.html#a9b62d38eabd5697e6470592c52226e4a">clone</a>();
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <span class="comment">// makeCall function family</span>
<a name="l00246"></a>00246     <span class="comment">// accepts a bare function, boost function, member function</span>
<a name="l00247"></a>00247     <span class="comment">// we handled byval/byref in refMask/transformRef, so bypass</span>
<a name="l00248"></a>00248     <span class="comment">// entirely ptrFromStorage.</span>
<a name="l00249"></a>00249 
<a name="l00250"></a><a class="code" href="a00397.html#a059af9e13093fdb317fb3f9cdc8b8e83">00250</a> <span class="preprocessor">#define callArg(z, n, _) \</span>
<a name="l00251"></a>00251 <span class="preprocessor">  BOOST_PP_COMMA_IF(n) * (typename boost::remove_reference&lt;P##n&gt;::type*)args[n]</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span><span class="preprocessor">#define makeCall(n, argstypedecl, argstype, argsdecl, argsues, comma) \</span>
<a name="l00253"></a>00253 <span class="preprocessor">  template &lt;typename R comma argstypedecl&gt;                            \</span>
<a name="l00254"></a>00254 <span class="preprocessor">  void* makeCall(R (*f)(argstype), void** args)                       \</span>
<a name="l00255"></a>00255 <span class="preprocessor">  {                                                                   \</span>
<a name="l00256"></a>00256 <span class="preprocessor">    detail::AnyReferenceCopy val;                                     \</span>
<a name="l00257"></a>00257 <span class="preprocessor">    val(), f(BOOST_PP_REPEAT(n, callArg, _));                         \</span>
<a name="l00258"></a>00258 <span class="preprocessor">    return val.rawValue();                                            \</span>
<a name="l00259"></a>00259 <span class="preprocessor">  }</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>    <a class="code" href="a00385.html#a13ce86db8d0df550bc3f38cf6ae2d533">QI_GEN</a>(<a class="code" href="a00397.html#a81e900212e341ce45fe04f0539866a30">makeCall</a>)
<a name="l00261"></a>00261 <span class="preprocessor">#undef makeCall</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span>
<a name="l00263"></a>00263 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span><span class="preprocessor">#define STATIC_IF_SAFE</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00266"></a><a class="code" href="a00397.html#af81f55e9c8b1c46c448bad56d5a4e268">00266</a> <span class="preprocessor"></span><span class="preprocessor">#define STATIC_IF_SAFE static</span>
<a name="l00267"></a>00267 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span>
<a name="l00269"></a>00269 <span class="comment">// hacks are disabled for boost::function (refMask forced to 0)</span>
<a name="l00270"></a>00270 <span class="comment">// so use ptrFromStorage.</span>
<a name="l00271"></a><a class="code" href="a00397.html#a9746b428f1a21461262b85c247139d3d">00271</a> <span class="preprocessor">#define declType(z, n, _)                  \</span>
<a name="l00272"></a>00272 <span class="preprocessor">  STATIC_IF_SAFE TypeInterface* type_##n = \</span>
<a name="l00273"></a>00273 <span class="preprocessor">      typeOf&lt;typename boost::remove_reference&lt;P##n&gt;::type&gt;();</span>
<a name="l00274"></a><a class="code" href="a00397.html#a834d2f5a7b9bc31c1195785d61c0ff0d">00274</a> <span class="preprocessor"></span><span class="preprocessor">#define callArgBF(z, n, _)                                               \</span>
<a name="l00275"></a>00275 <span class="preprocessor">  BOOST_PP_COMMA_IF(n) * (typename boost::remove_reference&lt;P##n&gt;::type*) \</span>
<a name="l00276"></a>00276 <span class="preprocessor">      type_##n-&gt;ptrFromStorage(&amp;args[n])</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span>
<a name="l00278"></a>00278 <span class="preprocessor">#define makeCall(n, argstypedecl, argstype, argsdecl, argsues, comma) \</span>
<a name="l00279"></a>00279 <span class="preprocessor">  template &lt;typename R comma argstypedecl&gt;                            \</span>
<a name="l00280"></a>00280 <span class="preprocessor">  void* makeCall(boost::function&lt;R(argstype)&gt; f, void** args)         \</span>
<a name="l00281"></a>00281 <span class="preprocessor">  {                                                                   \</span>
<a name="l00282"></a>00282 <span class="preprocessor">    BOOST_PP_REPEAT(n, declType, _) detail::AnyReferenceCopy val;     \</span>
<a name="l00283"></a>00283 <span class="preprocessor">    val(), f(BOOST_PP_REPEAT(n, callArgBF, _));                       \</span>
<a name="l00284"></a>00284 <span class="preprocessor">    return val.rawValue();                                            \</span>
<a name="l00285"></a>00285 <span class="preprocessor">  }</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>    <a class="code" href="a00385.html#a13ce86db8d0df550bc3f38cf6ae2d533">QI_GEN</a>(<a class="code" href="a00397.html#a81e900212e341ce45fe04f0539866a30">makeCall</a>)
<a name="l00287"></a>00287 <span class="preprocessor">#undef makeCall</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>
<a name="l00289"></a><a class="code" href="a00397.html#a81e900212e341ce45fe04f0539866a30">00289</a> <span class="preprocessor">#define makeCall(n, argstypedecl, argstype, argsdecl, argsues, comma)  \</span>
<a name="l00290"></a>00290 <span class="preprocessor">  template &lt;typename R comma argstypedecl&gt;                             \</span>
<a name="l00291"></a>00291 <span class="preprocessor">  void* makeCall(R (Class::*f)(argstype), void* instance, void** args) \</span>
<a name="l00292"></a>00292 <span class="preprocessor">  {                                                                    \</span>
<a name="l00293"></a>00293 <span class="preprocessor">    detail::AnyReferenceCopy val;                                      \</span>
<a name="l00294"></a>00294 <span class="preprocessor">    Class* cptr = *(Class**)instance;                                  \</span>
<a name="l00295"></a>00295 <span class="preprocessor">    val(), ((*cptr).*f)(BOOST_PP_REPEAT(n, callArg, _));               \</span>
<a name="l00296"></a>00296 <span class="preprocessor">    return val.rawValue();                                             \</span>
<a name="l00297"></a>00297 <span class="preprocessor">  }</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>    <a class="code" href="a00385.html#a13ce86db8d0df550bc3f38cf6ae2d533">QI_GEN</a>(<a class="code" href="a00397.html#a81e900212e341ce45fe04f0539866a30">makeCall</a>)
<a name="l00299"></a>00299 <span class="preprocessor">#undef makeCall</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>
<a name="l00301"></a><a class="code" href="a00397.html#a003370e7014c6f13697b2ec2d4f49000">00301</a> <span class="preprocessor">#define makeCall_(n, argstypedecl, argstype, argsdecl, argsues, comma) \</span>
<a name="l00302"></a>00302 <span class="preprocessor">  template &lt;typename R comma argstypedecl&gt;                             \</span>
<a name="l00303"></a>00303 <span class="preprocessor">  void* makeCall(R (Class::*f)(argstype), void** args)                 \</span>
<a name="l00304"></a>00304 <span class="preprocessor">  {                                                                    \</span>
<a name="l00305"></a>00305 <span class="preprocessor">    return makeCall(f, args[0], args + 1);                             \</span>
<a name="l00306"></a>00306 <span class="preprocessor">  }</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00308"></a>00308     <a class="code" href="a00385.html#a13ce86db8d0df550bc3f38cf6ae2d533">QI_GEN</a>(<a class="code" href="a00397.html#a003370e7014c6f13697b2ec2d4f49000">makeCall_</a>)
<a name="l00309"></a>00309 <span class="preprocessor">#undef callArg</span>
<a name="l00310"></a>00310 <span class="preprocessor"></span><span class="preprocessor">#undef makeCall_</span>
<a name="l00311"></a>00311 <span class="preprocessor"></span>
<a name="l00312"></a>00312 <span class="preprocessor">#ifdef QITYPE_TRACK_FUNCTIONTYPE_INSTANCES</span>
<a name="l00313"></a>00313 <span class="preprocessor"></span>    <span class="comment">// debug-tool to monitor function type usage</span>
<a name="l00314"></a>00314     <span class="keywordtype">void</span> <a class="code" href="a00340.html#ac45a270021d1bfae15cc079cbc39c4a4">QI_API</a> functionTypeTrack(<span class="keyword">const</span> std::string&amp; functionName);
<a name="l00315"></a>00315     <span class="keywordtype">void</span> <a class="code" href="a00340.html#ac45a270021d1bfae15cc079cbc39c4a4">QI_API</a> functionTypeDump();
<a name="l00316"></a>00316 <span class="preprocessor">#endif</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span>  }
<a name="l00318"></a>00318 
<a name="l00319"></a><a class="code" href="a00218.html">00319</a>   <span class="keyword">struct </span><a class="code" href="a00218.html">InfosKeyMask</a>: <span class="keyword">public</span> std::vector&lt;TypeInterface*&gt;
<a name="l00320"></a>00320   {
<a name="l00321"></a>00321   <span class="keyword">public</span>:
<a name="l00322"></a><a class="code" href="a00218.html#a7c110ba00d0a7ac15eae8b1cc077d334">00322</a>     <a class="code" href="a00218.html#a7c110ba00d0a7ac15eae8b1cc077d334">InfosKeyMask</a>(<span class="keyword">const</span> std::vector&lt;TypeInterface*&gt;&amp; b, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask)
<a name="l00323"></a>00323       : std::vector&lt;<a class="code" href="a00315.html">TypeInterface</a>*&gt;(b), <a class="code" href="a00218.html#adb669ad9a71d1af9a8259c1a9d5d2454">_mask</a>(mask) {}
<a name="l00324"></a><a class="code" href="a00218.html#ad8316297d3109204eb606e0a9d983406">00324</a>     <span class="keywordtype">bool</span> <a class="code" href="a00218.html#ad8316297d3109204eb606e0a9d983406">operator &lt; </a>(<span class="keyword">const</span> <a class="code" href="a00218.html">InfosKeyMask</a>&amp; b)<span class="keyword"> const</span>
<a name="l00325"></a>00325 <span class="keyword">    </span>{
<a name="l00326"></a>00326       <span class="keywordflow">if</span> (size() != b.size())
<a name="l00327"></a>00327         <span class="keywordflow">return</span> size() &lt; b.size();
<a name="l00328"></a>00328       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;size(); ++i)
<a name="l00329"></a>00329       {
<a name="l00330"></a>00330         <span class="keywordflow">if</span> ( (*<span class="keyword">this</span>)[i]-&gt;info() != b[i]-&gt;info())
<a name="l00331"></a>00331           <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[i]-&gt;info() &lt; b[i]-&gt;info();
<a name="l00332"></a>00332       }
<a name="l00333"></a>00333       <span class="keywordflow">return</span> <a class="code" href="a00218.html#adb669ad9a71d1af9a8259c1a9d5d2454">_mask</a> &lt; b.<a class="code" href="a00218.html#adb669ad9a71d1af9a8259c1a9d5d2454">_mask</a>;
<a name="l00334"></a>00334     }
<a name="l00335"></a><a class="code" href="a00218.html#adb669ad9a71d1af9a8259c1a9d5d2454">00335</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00218.html#adb669ad9a71d1af9a8259c1a9d5d2454">_mask</a>;
<a name="l00336"></a>00336   };
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="comment">/* T is the *reducted* function type</span>
<a name="l00339"></a>00339 <span class="comment">  *  S is the storage type of the function</span>
<a name="l00340"></a>00340 <span class="comment">  * So each instance must know the refMask, and the real return type</span>
<a name="l00341"></a>00341 <span class="comment">  *</span>
<a name="l00342"></a>00342 <span class="comment">  * categories of S in use:</span>
<a name="l00343"></a>00343 <span class="comment">  *  boost::function: no reduction performed</span>
<a name="l00344"></a>00344 <span class="comment">  *  bare function pointer</span>
<a name="l00345"></a>00345 <span class="comment">  *  member function pointer: T is the linearized signature</span>
<a name="l00346"></a>00346 <span class="comment">  */</span>
<a name="l00347"></a>00347   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;
<a name="l00348"></a><a class="code" href="a00203.html">00348</a>   <span class="keyword">class </span><a class="code" href="a00203.html">FunctionTypeInterfaceEq</a>: <span class="keyword">public</span> <a class="code" href="a00202.html">FunctionTypeInterface</a>
<a name="l00349"></a>00349   {
<a name="l00350"></a>00350   <span class="keyword">public</span>:
<a name="l00351"></a><a class="code" href="a00203.html#ae868846c8b7fa8d6133de2fe45135c0d">00351</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;T&gt;::type <a class="code" href="a00203.html#ae868846c8b7fa8d6133de2fe45135c0d">ReturnType</a>;
<a name="l00352"></a><a class="code" href="a00203.html#ad009cde1c21731d3a2a75dbc4c1c6e5c">00352</a>     <a class="code" href="a00203.html#ad009cde1c21731d3a2a75dbc4c1c6e5c">FunctionTypeInterfaceEq</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00203.html#a5b1d76fa8a7bff914e7271ed7dd9929d">refMask</a>)
<a name="l00353"></a>00353       : refMask(refMask)
<a name="l00354"></a>00354     {
<a name="l00355"></a>00355 <span class="preprocessor">#ifdef QITYPE_TRACK_FUNCTIONTYPE_INSTANCES</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span>      detail::functionTypeTrack(<span class="keyword">typeid</span>(S).name());
<a name="l00357"></a>00357 <span class="preprocessor">#endif</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span>    }
<a name="l00359"></a><a class="code" href="a00203.html#afb7a8302e97648634dce4fcf1a14a749">00359</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span>* <a class="code" href="a00203.html#afb7a8302e97648634dce4fcf1a14a749">call</a>(<span class="keywordtype">void</span>* storage, <span class="keywordtype">void</span>** args, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> argc)
<a name="l00360"></a>00360     {
<a name="l00361"></a>00361 <span class="preprocessor">#if QI_HAS_VARIABLE_LENGTH_ARRAY</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>      <span class="keywordtype">void</span>* out[argc];
<a name="l00363"></a>00363 <span class="preprocessor">#else</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span>      <span class="keywordtype">void</span>* outStatic[8];
<a name="l00365"></a>00365       <span class="keywordtype">void</span>** out;
<a name="l00366"></a>00366       <span class="keywordflow">if</span> (argc &lt;= 8)
<a name="l00367"></a>00367         out = outStatic;
<a name="l00368"></a>00368       <span class="keywordflow">else</span>
<a name="l00369"></a>00369         out = <span class="keyword">new</span> <span class="keywordtype">void</span>*[argc];
<a name="l00370"></a>00370 <span class="preprocessor">#endif</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span>      <a class="code" href="a00450.html#a8a86eb8570a7c7aad7d02732daf90387">detail::transformRef</a>(args, out, argc, <a class="code" href="a00203.html#a5b1d76fa8a7bff914e7271ed7dd9929d">refMask</a>);
<a name="l00372"></a>00372       <span class="keywordtype">void</span>* v = <a class="code" href="a00397.html#a81e900212e341ce45fe04f0539866a30">detail::makeCall</a>(*(S*)<a class="code" href="a00315.html#a898494917018ae1d9586599303c68285">ptrFromStorage</a>(&amp;storage), (<span class="keywordtype">void</span>**)out);
<a name="l00373"></a>00373       <span class="comment">// v is storage for type ReturnType we claimed we were</span>
<a name="l00374"></a>00374       <span class="comment">// adapt return value if needed</span>
<a name="l00375"></a>00375       <span class="keywordflow">if</span> (boost::is_pointer&lt;ReturnType&gt;::value
<a name="l00376"></a>00376           &amp;&amp;  <a class="code" href="a00038.html#a47236e6ed9c8641bb8b7c76d7a68ac09">_resultType</a>-&gt;<a class="code" href="a00315.html#a2e9435156f2cbbb224c97355311c1665">kind</a>() != <a class="code" href="a00359.html#ae01d947882857905031a3773561d3d83ac588aa7668f30929b99f7b51e164d85e">TypeKind_Pointer</a>)
<a name="l00377"></a>00377       {
<a name="l00378"></a>00378         <span class="comment">// if refMask&amp;1, real return type is some Foo&amp; and v is Foo*</span>
<a name="l00379"></a>00379         <span class="comment">// else, return type is Foo with sizeof(Foo) == sizeof(void*) and v is a Foo</span>
<a name="l00380"></a>00380         <span class="keywordtype">void</span>* vstorage = <a class="code" href="a00038.html#a47236e6ed9c8641bb8b7c76d7a68ac09">_resultType</a>-&gt;<a class="code" href="a00315.html#a3703cbf29428dbf209841b71cf382926">initializeStorage</a>(
<a name="l00381"></a>00381               (<a class="code" href="a00203.html#a5b1d76fa8a7bff914e7271ed7dd9929d">refMask</a>&amp;1)? v: &amp;v);
<a name="l00382"></a>00382         vstorage = <a class="code" href="a00038.html#a47236e6ed9c8641bb8b7c76d7a68ac09">_resultType</a>-&gt;<a class="code" href="a00315.html#a6aa1c92dec9f8d08a43767dbf99ca81e" title="Allocate a storage and copy the value given as an argument.">clone</a>(vstorage);
<a name="l00383"></a>00383         <span class="comment">//qiLogWarning(&quot;ft&quot;) &lt;&lt; &quot;Ret deref &quot; &lt;&lt; (unsigned long)v &lt;&lt;&#39; &#39; &lt;&lt; vstorage</span>
<a name="l00384"></a>00384         <span class="comment">// &lt;&lt; &#39; &#39; &lt;&lt; *(unsigned long*)vstorage;</span>
<a name="l00385"></a>00385         v = vstorage;
<a name="l00386"></a>00386       }
<a name="l00387"></a>00387 <span class="preprocessor">#if ! QI_HAS_VARIABLE_LENGTH_ARRAY</span>
<a name="l00388"></a>00388 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (argc &gt; 8)
<a name="l00389"></a>00389         <span class="keyword">delete</span>[] out;
<a name="l00390"></a>00390 <span class="preprocessor">#endif</span>
<a name="l00391"></a>00391 <span class="preprocessor"></span>      <span class="keywordflow">return</span> v;
<a name="l00392"></a>00392     }
<a name="l00393"></a><a class="code" href="a00203.html#a5b1d76fa8a7bff914e7271ed7dd9929d">00393</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00203.html#a5b1d76fa8a7bff914e7271ed7dd9929d">refMask</a>;
<a name="l00394"></a><a class="code" href="a00203.html#a7abaddb9fa147f86b2c52749c03b54ff">00394</a>     <span class="keyword">static</span> <a class="code" href="a00203.html">FunctionTypeInterfaceEq&lt;T, S&gt;</a>* <a class="code" href="a00203.html#a7abaddb9fa147f86b2c52749c03b54ff">make</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00203.html#a5b1d76fa8a7bff914e7271ed7dd9929d">refMask</a>, std::vector&lt;TypeInterface*&gt; argsType,
<a name="l00395"></a>00395                                                <a class="code" href="a00315.html">TypeInterface</a>* returnType)
<a name="l00396"></a>00396     { <span class="comment">// we need to hash/compare on all the arguments</span>
<a name="l00397"></a>00397       std::vector&lt;TypeInterface*&gt; key(argsType);
<a name="l00398"></a>00398       key.push_back(returnType);
<a name="l00399"></a>00399       <span class="keyword">typedef</span> std::map&lt;InfosKeyMask,  FunctionTypeInterfaceEq&lt;T, S&gt;* &gt; FTMap;
<a name="l00400"></a>00400       <span class="keyword">static</span> FTMap* ftMap = 0;
<a name="l00401"></a>00401       <span class="keyword">static</span> boost::mutex* mutex = 0;
<a name="l00402"></a>00402       <a class="code" href="a00343.html#aaaedb2ddd5c47c1e0554a3c2eec908a4">QI_THREADSAFE_NEW</a>(ftMap, mutex);
<a name="l00403"></a>00403       boost::mutex::scoped_lock lock(*mutex);
<a name="l00404"></a>00404       <a class="code" href="a00203.html">FunctionTypeInterfaceEq&lt;T, S&gt;</a>* &amp; fptr = (*ftMap)[<a class="code" href="a00218.html">InfosKeyMask</a>(key, refMask)];
<a name="l00405"></a>00405       <span class="keywordflow">if</span> (!fptr)
<a name="l00406"></a>00406       {
<a name="l00407"></a>00407         fptr = <span class="keyword">new</span> <a class="code" href="a00203.html">FunctionTypeInterfaceEq&lt;T, S&gt;</a>(<a class="code" href="a00203.html#a5b1d76fa8a7bff914e7271ed7dd9929d">refMask</a>);
<a name="l00408"></a>00408         fptr-&gt;<a class="code" href="a00038.html#a47236e6ed9c8641bb8b7c76d7a68ac09">_resultType</a> = returnType;
<a name="l00409"></a>00409         fptr-&gt;<a class="code" href="a00038.html#ae54cbbcc296b3021d6a1f11f137aead8">_argumentsType</a> = argsType;
<a name="l00410"></a>00410       }
<a name="l00411"></a>00411       <span class="keywordflow">return</span> fptr;
<a name="l00412"></a>00412     }
<a name="l00413"></a>00413     <a class="code" href="a00203.html#ae079dfd8ef51a850ed6002e614192563">_QI_BOUNCE_TYPE_METHODS</a>(<a class="code" href="a00041.html">DefaultTypeImplMethods&lt;S&gt;</a>);
<a name="l00414"></a>00414   };
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   <span class="keyword">namespace </span>detail
<a name="l00417"></a>00417   {
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     <span class="comment">// Trick used to avoid instanciating a T</span>
<a name="l00420"></a><a class="code" href="a00113.html">00420</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00113.html">Ident</a>
<a name="l00421"></a>00421     {
<a name="l00422"></a>00422     };
<a name="l00423"></a>00423 
<a name="l00424"></a><a class="code" href="a00075.html">00424</a>     <span class="keyword">struct </span><a class="code" href="a00075.html">checkForNonConstRef</a>
<a name="l00425"></a>00425     {
<a name="l00426"></a><a class="code" href="a00075.html#aad9cbe11755659f9c36f1648be414279">00426</a>       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="a00075.html#aad9cbe11755659f9c36f1648be414279">operator()</a>(<a class="code" href="a00113.html">Ident&lt;T&gt;</a>)
<a name="l00427"></a>00427       {
<a name="l00428"></a>00428         <a class="code" href="a00364.html#a1a8b0c9365f5fbef078682fcf10e8135">qiLogCategory</a>(<span class="stringliteral">&quot;qitype.functiontypefactory&quot;</span>);
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (boost::is_reference&lt;T&gt;::value &amp;&amp; !boost::is_const&lt;
<a name="l00430"></a>00430             <span class="keyword">typename</span> boost::remove_reference&lt;T&gt;::type&gt;::value)
<a name="l00431"></a>00431           <a class="code" href="a00364.html#a99b1c08c85f656dd731c8ddd6d1edc36" title="Log in warning mode.">qiLogWarning</a>() &lt;&lt; <span class="stringliteral">&quot;Function argument is a non-const reference: &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T).name();
<a name="l00432"></a>00432       }
<a name="l00433"></a>00433     };
<a name="l00434"></a><a class="code" href="a00138.html">00434</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00138.html">remove_constptr</a>
<a name="l00435"></a>00435     {
<a name="l00436"></a><a class="code" href="a00138.html#a09f353be402701e24fde4ba52a4847e9">00436</a>       <span class="keyword">typedef</span> T <a class="code" href="a00138.html#a09f353be402701e24fde4ba52a4847e9">type</a>;
<a name="l00437"></a>00437     };
<a name="l00438"></a><a class="code" href="a00139.html">00438</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00138.html">remove_constptr</a>&lt;const T*&gt;
<a name="l00439"></a>00439     {
<a name="l00440"></a><a class="code" href="a00139.html#a79a9cace921359d50639c68bfd74827d">00440</a>       <span class="keyword">typedef</span> T* <a class="code" href="a00139.html#a79a9cace921359d50639c68bfd74827d">type</a>;
<a name="l00441"></a>00441     };
<a name="l00442"></a>00442     <span class="comment">// Fill a vector&lt;TypeInterface*&gt; from a T*</span>
<a name="l00443"></a><a class="code" href="a00092.html">00443</a>     <span class="keyword">struct </span><a class="code" href="a00092.html">fill_arguments</a>
<a name="l00444"></a>00444     {
<a name="l00445"></a><a class="code" href="a00092.html#a943036fc9833a0f613ecbb1ba193677c">00445</a>       <span class="keyword">inline</span> <a class="code" href="a00092.html#a943036fc9833a0f613ecbb1ba193677c">fill_arguments</a>(std::vector&lt;TypeInterface*&gt;* <a class="code" href="a00092.html#ae4617f6da4c55e0293a67fdf84abb413">target</a>)
<a name="l00446"></a>00446         : target(target) {}
<a name="l00447"></a>00447 
<a name="l00448"></a><a class="code" href="a00092.html#a8715fca27c454065e6ec60d3e65ee2cd">00448</a>       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="a00092.html#a8715fca27c454065e6ec60d3e65ee2cd">operator()</a>(T*)<span class="keyword"> const</span>
<a name="l00449"></a>00449 <span class="keyword">      </span>{
<a name="l00450"></a>00450         <a class="code" href="a00315.html">TypeInterface</a>* result = <a class="code" href="a00359.html#a45c4fec4058dee00453ef20d1c544eec">typeOf</a>&lt;
<a name="l00451"></a>00451             <span class="keyword">typename</span> <a class="code" href="a00138.html">remove_constptr</a>&lt;
<a name="l00452"></a>00452             <span class="keyword">typename</span> boost::remove_const&lt;
<a name="l00453"></a>00453             <span class="keyword">typename</span> boost::remove_reference&lt;T&gt;::type
<a name="l00454"></a>00454             &gt;::type&gt;::type&gt;();
<a name="l00455"></a>00455         <a class="code" href="a00092.html#ae4617f6da4c55e0293a67fdf84abb413">target</a>-&gt;push_back(result);
<a name="l00456"></a>00456       }
<a name="l00457"></a><a class="code" href="a00092.html#ae4617f6da4c55e0293a67fdf84abb413">00457</a>       std::vector&lt;TypeInterface*&gt;* <a class="code" href="a00092.html#ae4617f6da4c55e0293a67fdf84abb413">target</a>;
<a name="l00458"></a>00458     };
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <span class="comment">// build a function pointer or member function pointer type</span>
<a name="l00461"></a><a class="code" href="a00095.html">00461</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keywordtype">bool</span> Member&gt; <span class="keyword">struct </span><a class="code" href="a00095.html">FunctionPointerSynthetizer</a>
<a name="l00462"></a>00462     {
<a name="l00463"></a><a class="code" href="a00095.html#ac7e18c6edafa826970e1df6ebdbfac55">00463</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span>  boost::function_types::member_function_pointer&lt;F&gt;::type <a class="code" href="a00095.html#ac7e18c6edafa826970e1df6ebdbfac55">type</a>;
<a name="l00464"></a>00464     };
<a name="l00465"></a><a class="code" href="a00096.html">00465</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt; <span class="keyword">struct </span><a class="code" href="a00095.html">FunctionPointerSynthetizer</a>&lt;F, false&gt;
<a name="l00466"></a>00466     {
<a name="l00467"></a><a class="code" href="a00096.html#a451f4da1341ae4b8e4a5e9189c20da08">00467</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::function_pointer&lt;F&gt;::type <a class="code" href="a00096.html#a451f4da1341ae4b8e4a5e9189c20da08">type</a>;
<a name="l00468"></a>00468     };
<a name="l00469"></a>00469     <span class="comment">// Accept a function pointer or member function pointer</span>
<a name="l00470"></a>00470     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;
<a name="l00471"></a><a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">00471</a>     <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">makeAnyFunctionBare</a>(F func)
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::parameter_types&lt;F&gt;::type ArgsType;
<a name="l00474"></a>00474       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;F&gt;::type ResType;
<a name="l00475"></a>00475       <a class="code" href="a00315.html">TypeInterface</a>* resultType = typeOf&lt;ResType&gt;();
<a name="l00476"></a>00476       std::vector&lt;TypeInterface*&gt; argumentsType;
<a name="l00477"></a>00477       <span class="comment">// Generate and store a TypeInterface* for each argument</span>
<a name="l00478"></a>00478       boost::mpl::for_each&lt;
<a name="l00479"></a>00479           boost::mpl::transform_view&lt;ArgsType,
<a name="l00480"></a>00480           boost::add_pointer&lt;
<a name="l00481"></a>00481           boost::remove_const&lt;
<a name="l00482"></a>00482           boost::remove_reference&lt;boost::mpl::_1&gt; &gt; &gt; &gt; &gt;(<a class="code" href="a00092.html">detail::fill_arguments</a>(&amp;argumentsType));
<a name="l00483"></a>00483       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00079.html">EqFunction&lt;F&gt;::type</a> MapedF;
<a name="l00484"></a>00484       <span class="comment">// regenerate eq function pointer type</span>
<a name="l00485"></a>00485       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::components&lt;MapedF&gt;::type EqComponents;
<a name="l00486"></a>00486       <span class="comment">// would have used mpl::if_ but it has laziness issues it seems</span>
<a name="l00487"></a>00487       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00095.html">FunctionPointerSynthetizer</a>&lt;EqComponents,
<a name="l00488"></a>00488           boost::is_member_function_pointer&lt;F&gt;::value&gt;::type EqFunPtr;
<a name="l00489"></a>00489       <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mask = <a class="code" href="a00079.html">EqFunction&lt;F&gt;::refMask</a>;
<a name="l00490"></a>00490       <a class="code" href="a00202.html">FunctionTypeInterface</a>* ftype = <a class="code" href="a00203.html">FunctionTypeInterfaceEq&lt;MapedF, EqFunPtr&gt;::make</a>(mask, argumentsType, resultType);
<a name="l00491"></a>00491 
<a name="l00492"></a>00492       <a class="code" href="a00364.html#ab87485b8572032c41e89d03a87bb08f2">qiLogDebug</a>(<span class="stringliteral">&quot;qitype.makeAnyFunction&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;bare mask &quot;</span> &lt;&lt; (<span class="keywordtype">unsigned</span> long)<a class="code" href="a00079.html">EqFunction&lt;F&gt;::refMask</a>;
<a name="l00493"></a>00493       <span class="keywordflow">return</span> <a class="code" href="a00020.html">AnyFunction</a>(ftype, ftype-&gt;<a class="code" href="a00315.html#a6aa1c92dec9f8d08a43767dbf99ca81e" title="Allocate a storage and copy the value given as an argument.">clone</a>(ftype-&gt;<a class="code" href="a00315.html#a3703cbf29428dbf209841b71cf382926">initializeStorage</a>(&amp;func)));
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R&gt;
<a name="l00497"></a><a class="code" href="a00450.html#a5ec9a1395f299019da939181a6ff95a6">00497</a>     <a class="code" href="a00023.html">AnyReference</a> <a class="code" href="a00450.html#a5ec9a1395f299019da939181a6ff95a6">bouncer</a>(<span class="keyword">const</span> <a class="code" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a>&amp; vargs,
<a name="l00498"></a>00498                          R (C::*fun)(<span class="keyword">const</span> <a class="code" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a>&amp;)
<a name="l00499"></a>00499                          )
<a name="l00500"></a>00500     {
<a name="l00501"></a>00501       <span class="comment">// Pack arguments, call, wrap return value in AnyValue</span>
<a name="l00502"></a>00502       <a class="code" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a> nargs;
<a name="l00503"></a>00503       nargs.<a class="code" href="a00019.html#aaee59620eb39fa2ab0e41a8eeb7bf118">args</a>().resize(vargs.size()-1);
<a name="l00504"></a>00504       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;vargs.size()-1; ++i)
<a name="l00505"></a>00505         nargs.<a class="code" href="a00019.html#aaee59620eb39fa2ab0e41a8eeb7bf118">args</a>()[i] = vargs[i+1];
<a name="l00506"></a>00506       C* inst = (C*)vargs.front().rawValue();
<a name="l00507"></a>00507       <span class="keywordflow">if</span> (!inst)
<a name="l00508"></a>00508         <a class="code" href="a00364.html#a99b1c08c85f656dd731c8ddd6d1edc36" title="Log in warning mode.">qiLogWarning</a>(<span class="stringliteral">&quot;qitype.AnyArgumentsBouncer&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;Null instance&quot;</span>;
<a name="l00509"></a>00509       <a class="code" href="a00055.html">detail::AnyReferenceCopy</a> output;
<a name="l00510"></a>00510       output(), (*inst.*fun)(nargs); <span class="comment">// output clones</span>
<a name="l00511"></a>00511       <a class="code" href="a00024.html">AnyValue</a>* v = <span class="keyword">new</span> <a class="code" href="a00024.html">AnyValue</a>(output, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">// steal output</span>
<a name="l00512"></a>00512       <span class="keywordflow">return</span> <a class="code" href="a00054.html#a64976ed2aefd1d85ffcf43b9168bef64">AnyReference::fromPtr</a>(v);
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;
<a name="l00516"></a><a class="code" href="a00450.html#ada6f2f8548fb77dcebba0d163b09bca6">00516</a>     <a class="code" href="a00023.html">AnyReference</a> <a class="code" href="a00450.html#ada6f2f8548fb77dcebba0d163b09bca6">bouncerBF</a>(<span class="keyword">const</span> <a class="code" href="a00359.html#af6526717e2ad65d93d8a801c099cc90a">AnyReferenceVector</a>&amp; vargs,
<a name="l00517"></a>00517                            boost::function&lt;R (<span class="keyword">const</span> <a class="code" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a>&amp;)&gt; f
<a name="l00518"></a>00518                            )
<a name="l00519"></a>00519     {
<a name="l00520"></a>00520       <a class="code" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a> nargs;
<a name="l00521"></a>00521       <span class="keywordflow">if</span>(!vargs.empty())
<a name="l00522"></a>00522       {
<a name="l00523"></a>00523         nargs.<a class="code" href="a00019.html#aaee59620eb39fa2ab0e41a8eeb7bf118">args</a>().resize(vargs.size());
<a name="l00524"></a>00524         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i=0; i&lt;vargs.size(); ++i)
<a name="l00525"></a>00525           nargs.<a class="code" href="a00019.html#aaee59620eb39fa2ab0e41a8eeb7bf118">args</a>()[i] = vargs[i];
<a name="l00526"></a>00526       }
<a name="l00527"></a>00527       <a class="code" href="a00055.html">detail::AnyReferenceCopy</a> output;
<a name="l00528"></a>00528       output(), f(nargs);
<a name="l00529"></a>00529       <a class="code" href="a00024.html">AnyValue</a>* v = <span class="keyword">new</span> <a class="code" href="a00024.html">AnyValue</a>(output, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">// steal output</span>
<a name="l00530"></a>00530       <span class="keywordflow">return</span> <a class="code" href="a00054.html#a64976ed2aefd1d85ffcf43b9168bef64">AnyReference::fromPtr</a>(v);
<a name="l00531"></a>00531     }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R&gt;
<a name="l00534"></a><a class="code" href="a00450.html#af9e2fc4b2213516ca5dbf8df91c588a2">00534</a>     <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">makeAnyFunctionBare</a>(R (C::*fun)(<span class="keyword">const</span> <a class="code" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a>&amp;))
<a name="l00535"></a>00535     {
<a name="l00536"></a>00536       <a class="code" href="a00020.html">AnyFunction</a> res = <a class="code" href="a00020.html#af84daf701221e75612b814b823f7a91b">AnyFunction::fromDynamicFunction</a>(<a class="code" href="a00359.html#a22ca99743b6c820547dea46057a73ae0">boost::bind</a>(&amp;bouncer&lt;C, R&gt;, _1, fun));
<a name="l00537"></a>00537       <span class="comment">// The signature storage in GO will drop first argument, and bug if none is present</span>
<a name="l00538"></a>00538       <span class="keyword">const_cast&lt;</span>std::vector&lt;TypeInterface*&gt; &amp;<span class="keyword">&gt;</span>(res.<a class="code" href="a00020.html#ab2be7e05f4aca7c20ec3982606474421">functionType</a>()-&gt;<a class="code" href="a00038.html#a80b2a4590cb68bc8df39db3ad9759c22">argumentsType</a>()).push_back(typeOf&lt;AnyValue&gt;());
<a name="l00539"></a>00539       <span class="keywordflow">return</span> res;
<a name="l00540"></a>00540     }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt;
<a name="l00543"></a><a class="code" href="a00450.html#a48fdc8e76f6b3aaa4dd773ea441fea36">00543</a>     <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">makeAnyFunctionBare</a>(R (*fun)(<span class="keyword">const</span> <a class="code" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a>&amp;))
<a name="l00544"></a>00544     {
<a name="l00545"></a>00545       boost::function&lt;R (const AnyArguments&amp;)&gt; fu = fun;
<a name="l00546"></a>00546       <a class="code" href="a00020.html">AnyFunction</a> res = <a class="code" href="a00020.html#af84daf701221e75612b814b823f7a91b">AnyFunction::fromDynamicFunction</a>(<a class="code" href="a00359.html#a22ca99743b6c820547dea46057a73ae0">boost::bind</a>(&amp;bouncerBF&lt;R&gt;, _1, fun));
<a name="l00547"></a>00547       <span class="comment">// The signature storage in GO will drop first argument, and bug if none is present</span>
<a name="l00548"></a>00548       <span class="keyword">const_cast&lt;</span>std::vector&lt;TypeInterface*&gt; &amp;<span class="keyword">&gt;</span>(res.<a class="code" href="a00020.html#ab2be7e05f4aca7c20ec3982606474421">functionType</a>()-&gt;<a class="code" href="a00038.html#a80b2a4590cb68bc8df39db3ad9759c22">argumentsType</a>()).push_back(typeOf&lt;AnyValue&gt;());
<a name="l00549"></a>00549       <span class="keywordflow">return</span> res;
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551 
<a name="l00552"></a><a class="code" href="a00450.html#a8f79a6620aceea8cefe1c78e55ef815b">00552</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R&gt; <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">makeAnyFunctionBare</a>(boost::function&lt;R (<span class="keyword">const</span> <a class="code" href="a00019.html" title="A function with AnyArguments as its sole argument will behave as if AnyFunction::fromDynamicFunction ...">AnyArguments</a>&amp;)&gt; fun)
<a name="l00553"></a>00553     {
<a name="l00554"></a>00554       <a class="code" href="a00020.html">AnyFunction</a> res = <a class="code" href="a00020.html#af84daf701221e75612b814b823f7a91b">AnyFunction::fromDynamicFunction</a>(<a class="code" href="a00359.html#a22ca99743b6c820547dea46057a73ae0">boost::bind</a>(&amp;bouncerBF&lt;R&gt;, _1, fun));
<a name="l00555"></a>00555       <span class="comment">// The signature storage in GO will drop first argument, and bug if none is present</span>
<a name="l00556"></a>00556       <span class="keyword">const_cast&lt;</span>std::vector&lt;TypeInterface*&gt; &amp;<span class="keyword">&gt;</span>(res.<a class="code" href="a00020.html#ab2be7e05f4aca7c20ec3982606474421">functionType</a>()-&gt;<a class="code" href="a00038.html#a80b2a4590cb68bc8df39db3ad9759c22">argumentsType</a>()).push_back(typeOf&lt;AnyValue&gt;());
<a name="l00557"></a>00557       <span class="keywordflow">return</span> res;
<a name="l00558"></a>00558     }
<a name="l00559"></a>00559 
<a name="l00560"></a><a class="code" href="a00450.html#a9024c518b3791a21e3b4b49861fa5953">00560</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt; <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">makeAnyFunctionBare</a>(boost::function&lt;F&gt; func)
<a name="l00561"></a>00561     {
<a name="l00562"></a>00562       <span class="comment">/* Do not try to reduce anything on a boost::function.</span>
<a name="l00563"></a>00563 <span class="comment">      * It will bounce to an internal template backend anyway</span>
<a name="l00564"></a>00564 <span class="comment">      */</span>
<a name="l00565"></a>00565       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::parameter_types&lt;F&gt;::type ArgsType;
<a name="l00566"></a>00566       <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;F&gt;::type ResType;
<a name="l00567"></a>00567       <a class="code" href="a00315.html">TypeInterface</a>* resultType = typeOf&lt;ResType&gt;();
<a name="l00568"></a>00568       std::vector&lt;TypeInterface*&gt; argumentsType;
<a name="l00569"></a>00569       boost::mpl::for_each&lt;
<a name="l00570"></a>00570           boost::mpl::transform_view&lt;ArgsType,
<a name="l00571"></a>00571           boost::add_pointer&lt;
<a name="l00572"></a>00572           boost::remove_const&lt;
<a name="l00573"></a>00573           boost::remove_reference&lt;boost::mpl::_1&gt; &gt; &gt; &gt; &gt;(<a class="code" href="a00092.html">detail::fill_arguments</a>(&amp;argumentsType));
<a name="l00574"></a>00574       <a class="code" href="a00202.html">FunctionTypeInterface</a>* ftype = <a class="code" href="a00203.html">FunctionTypeInterfaceEq&lt;F, boost::function&lt;F&gt;</a> &gt;::make(0, argumentsType, resultType);
<a name="l00575"></a>00575       <span class="keywordflow">return</span> <a class="code" href="a00020.html">AnyFunction</a>(ftype, <span class="keyword">new</span> boost::function&lt;F&gt;(func));
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578     <span class="comment">// Use helper structures for which template partial specialisation is possible</span>
<a name="l00579"></a><a class="code" href="a00048.html">00579</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00048.html">AnyFunctionMaker</a>
<a name="l00580"></a>00580     {
<a name="l00581"></a><a class="code" href="a00048.html#a58512d002015eef548d56fec21ea9773">00581</a>       <span class="keyword">static</span> <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00048.html#a58512d002015eef548d56fec21ea9773">make</a>(T func)
<a name="l00582"></a>00582       {
<a name="l00583"></a>00583         <span class="keywordflow">return</span> <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">makeAnyFunctionBare</a>(func);
<a name="l00584"></a>00584       }
<a name="l00585"></a>00585     };
<a name="l00586"></a><a class="code" href="a00053.html">00586</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00048.html">AnyFunctionMaker</a>&lt;T*&gt;
<a name="l00587"></a>00587     {
<a name="l00588"></a><a class="code" href="a00053.html#a617722ed2dc7cef439018161e46fad55">00588</a>       <span class="keyword">static</span> <a class="code" href="a00020.html">AnyFunction</a> make(T* func)
<a name="l00589"></a>00589       {
<a name="l00590"></a>00590         <span class="keywordflow">return</span> <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">makeAnyFunctionBare</a>(func);
<a name="l00591"></a>00591       }
<a name="l00592"></a>00592     };
<a name="l00593"></a>00593     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> F, <span class="keyword">typename</span> B&gt;
<a name="l00594"></a><a class="code" href="a00050.html">00594</a>     <span class="keyword">struct </span><a class="code" href="a00048.html">AnyFunctionMaker</a>&lt;boost::_bi::bind_t&lt;R, F, B&gt; &gt;
<a name="l00595"></a>00595     {
<a name="l00596"></a><a class="code" href="a00050.html#ab40f31f0ca0393a7cd2651053137d8da">00596</a>       <span class="keyword">static</span> <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00048.html#a58512d002015eef548d56fec21ea9773">make</a>(boost::_bi::bind_t&lt;R, F, B&gt; v)
<a name="l00597"></a>00597       {
<a name="l00598"></a>00598         <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function&lt;<span class="keyword">typename</span> <a class="code" href="a00031.html">boost_bind_function_type</a>&lt;
<a name="l00599"></a>00599             boost::_bi::bind_t&lt;R, F, B&gt; &gt;::type&gt; CompatType;
<a name="l00600"></a>00600         CompatType f = v;
<a name="l00601"></a>00601         <span class="keywordflow">return</span> <a class="code" href="a00020.html#ae53a9a61c98c775fa60262104da1cd8f">AnyFunction::from</a>(f);
<a name="l00602"></a>00602       }
<a name="l00603"></a>00603     };
<a name="l00604"></a><a class="code" href="a00051.html">00604</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00048.html">AnyFunctionMaker</a>&lt;boost::<a class="code" href="a00006.html">function</a>&lt;T&gt; &gt;
<a name="l00605"></a>00605     {
<a name="l00606"></a><a class="code" href="a00051.html#a61fd6b321a13b8daded4fb3292bcbafc">00606</a>       <span class="keyword">static</span> <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00048.html#a58512d002015eef548d56fec21ea9773">make</a>(boost::function&lt;T&gt; func)
<a name="l00607"></a>00607       {
<a name="l00608"></a>00608         assert(<span class="keyword">sizeof</span>(boost::function&lt;T&gt;) == <span class="keyword">sizeof</span>(boost::function&lt;<span class="keywordtype">void</span> ()&gt;));
<a name="l00609"></a>00609         <a class="code" href="a00020.html">AnyFunction</a> res = <a class="code" href="a00450.html#a19355d0cc970a7518508cc6912a22b5a">detail::makeAnyFunctionBare</a>(func);
<a name="l00610"></a>00610         <span class="keywordflow">return</span> res;
<a name="l00611"></a>00611       }
<a name="l00612"></a>00612     };
<a name="l00613"></a><a class="code" href="a00052.html">00613</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00048.html">AnyFunctionMaker</a>&lt;const T&amp;&gt;
<a name="l00614"></a>00614         : <span class="keyword">public</span> <a class="code" href="a00048.html">AnyFunctionMaker&lt;T&gt;</a> {};
<a name="l00615"></a><a class="code" href="a00049.html">00615</a>     <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span><a class="code" href="a00048.html">AnyFunctionMaker</a>&lt;<a class="code" href="a00020.html">AnyFunction</a>&gt;
<a name="l00616"></a>00616     {
<a name="l00617"></a><a class="code" href="a00049.html#a33821ede3ca3a46ac6814b04b3ea0a7b">00617</a>       <span class="keyword">static</span> <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00048.html#a58512d002015eef548d56fec21ea9773">make</a>(<a class="code" href="a00020.html">AnyFunction</a> func)
<a name="l00618"></a>00618       {
<a name="l00619"></a>00619         <span class="keywordflow">return</span> func;
<a name="l00620"></a>00620       }
<a name="l00621"></a>00621     };
<a name="l00622"></a>00622   }
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00625"></a><a class="code" href="a00020.html#afa9729d8f00fd87d74a08df686b3eded">00625</a>   <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00020.html#ae53a9a61c98c775fa60262104da1cd8f">AnyFunction::from</a>(T f)
<a name="l00626"></a>00626   {
<a name="l00627"></a>00627     <span class="keywordflow">return</span> <a class="code" href="a00048.html">detail::AnyFunctionMaker&lt;T&gt;::make</a>(f);
<a name="l00628"></a>00628   }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   <span class="keyword">namespace </span>detail
<a name="l00631"></a>00631   {
<a name="l00632"></a><a class="code" href="a00132.html">00632</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00132.html">Pointer</a>
<a name="l00633"></a>00633     {
<a name="l00634"></a><a class="code" href="a00132.html#ab5277955cb2fe8150c26945d9765784f">00634</a>       <span class="keyword">static</span> T* <a class="code" href="a00132.html#ab5277955cb2fe8150c26945d9765784f">pointer</a>(T&amp; t)
<a name="l00635"></a>00635       {
<a name="l00636"></a>00636         <span class="keywordflow">return</span> &amp;t;
<a name="l00637"></a>00637       }
<a name="l00638"></a>00638     };
<a name="l00639"></a><a class="code" href="a00133.html">00639</a>     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="a00132.html">Pointer</a>&lt;T*&gt;
<a name="l00640"></a>00640     {
<a name="l00641"></a><a class="code" href="a00133.html#ad155f1b65d740afd069b44df42b5335a">00641</a>       <span class="keyword">static</span> T* pointer(T* &amp; t)
<a name="l00642"></a>00642       {
<a name="l00643"></a>00643         <span class="keywordflow">return</span> t;
<a name="l00644"></a>00644       }
<a name="l00645"></a>00645     };
<a name="l00646"></a>00646   }
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> C&gt;
<a name="l00649"></a><a class="code" href="a00020.html#a809da9acce9b5939e062a6d1d96ef18c">00649</a>   <a class="code" href="a00020.html">AnyFunction</a> <a class="code" href="a00020.html#ae53a9a61c98c775fa60262104da1cd8f">AnyFunction::from</a>(F func, C instance)
<a name="l00650"></a>00650   {
<a name="l00651"></a>00651     <span class="comment">/* Taking a AnyFunction of F will likely imply a typeOf&lt;C&gt; which is</span>
<a name="l00652"></a>00652 <span class="comment">    * unnecessary. So use a fake class in signature.</span>
<a name="l00653"></a>00653 <span class="comment">    */</span>
<a name="l00654"></a>00654     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;F&gt;::type Result;
<a name="l00655"></a>00655     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::parameter_types&lt;F, boost::mpl::identity&lt;boost::mpl::_1&gt; &gt;::type Args;
<a name="l00656"></a>00656     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::pop_front&lt;Args&gt;::type ArgsNoClass;
<a name="l00657"></a>00657     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::push_front&lt;ArgsNoClass, detail::Class&amp;&gt;::type ArgsFakeClass;
<a name="l00658"></a>00658     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::push_front&lt;ArgsFakeClass, Result&gt;::type ComponentsFaked;
<a name="l00659"></a>00659     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::member_function_pointer&lt;ComponentsFaked&gt;::type MethodTypeFaked;
<a name="l00660"></a>00660     MethodTypeFaked newFunk = *(MethodTypeFaked*)(<span class="keywordtype">void</span>*)&amp;func;
<a name="l00661"></a>00661     <a class="code" href="a00020.html">AnyFunction</a> res = <a class="code" href="a00020.html#ae53a9a61c98c775fa60262104da1cd8f">AnyFunction::from</a>(newFunk);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="comment">// Dynamic-cast instance to expected pointer type.</span>
<a name="l00664"></a>00664     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::mpl::at_c&lt;Args, 0&gt;::type FirstArg;
<a name="l00665"></a>00665     <span class="comment">// Get expected</span>
<a name="l00666"></a>00666     FirstArg* ptr = <span class="keyword">dynamic_cast&lt;</span>FirstArg*<span class="keyword">&gt;</span>(<a class="code" href="a00132.html">detail::Pointer&lt;C&gt;::pointer</a>(instance));
<a name="l00667"></a>00667     <span class="keywordflow">if</span> (!ptr &amp;&amp; instance)
<a name="l00668"></a>00668       <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;makeAnyFunction: failed to dynamic_cast bound value to expected type&quot;</span>);
<a name="l00669"></a>00669     res.<a class="code" href="a00020.html#ad82a987ed243bbeb50aa78e918f9e8b5" title="Prepend extra argument value to argument list.">prependArgument</a>((<span class="keywordtype">void</span>*)(<span class="keyword">const</span> <span class="keywordtype">void</span>*)ptr);
<a name="l00670"></a>00670     <span class="keywordflow">return</span> res;
<a name="l00671"></a>00671   }
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 <span class="preprocessor">#endif  // _QITYPE_DETAILS_ANYFUNCTIONFACTORY_HXX_</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Copyright Aldebaran Robotics
<!-- Generated on Wed Oct 29 2014 16:04:34 for libqi-api by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1</small></address> -->

</body>
</html>
