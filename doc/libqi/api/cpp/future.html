
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qi::Promise, qi::Future &mdash; qi SDK Documentation 2.2.0.55 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.0.55',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="qi SDK Documentation 2.2.0.55 documentation" href="../../index.html" />
    <link rel="up" title="C++ qi API Reference" href="index.html" />
    <link rel="next" title="qi::IOColor" href="iocolor.html" />
    <link rel="prev" title="qi::EventLoop" href="eventloop.html" />
 
<script>
$(window).ready(function () {
    var width_label = 0;
    $('dl.function-index dt > span').each(function () {
        $(this).css('width', 'auto');
        width_label = Math.max(width_label, $(this).width());
    }).width(width_label + 30);
    $('.sig-paren').width('auto');
})

</script>


<script type="text/javascript" src="/static/js/ga-status.js"></script>



  </head>
  <body>

    <div class="document">
  <div id="custom-doc" class="yui-t3">
    <div id="hd">
      <h1><a href="../../index.html">qi SDK Documentation 2.2.0.55 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">Home</a>
         |
        <a title="Site map" href="../../contents.html">Site map</a>
         |
        <a title="Search" href="../../search.html">Search</a>
         |
        <a title="Index" href="../../genindex.html">Index</a>
      </div>
      <div class="nav">
    &laquo; <a href="eventloop.html" title="qi::EventLoop">previous</a>
     |
    <a href="index.html" title="C++ qi API Reference" accesskey="U">up</a>
   |
    <a href="iocolor.html" title="qi::IOColor">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="api-cpp-future">
            
  <div class="section" id="qi-promise-qi-future">
<h1>qi::Promise, qi::Future<a class="headerlink" href="#qi-promise-qi-future" title="Permalink to this headline">¶</a></h1>
<p>The promise and future concepts allow one to provide a result asynchronously.
The implementor creates a promise for the result and returns the future
contained in the promise. The caller can then use the result of the future
later.</p>
<p>You can see a <a class="reference internal" href="#future-usage"><em>complete usage example</em></a> at the end of this
document.</p>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<strong><p class="rubric">Global Namespaces</p>
</strong><ul>
<li><p class="first">namespace qi</p>
<dl class="docutils">
<strong><p class="rubric">Classes (namespace qi)</p>
</strong><ul>
<li><p class="first">class qi::Future</p>
<dl class="docutils">
</dl>
</li>
<li><p class="first">class qi::Promise</p>
<dl class="docutils">
</dl>
</li>
<li><p class="first">class qi::FutureSync</p>
<dl class="docutils">
</dl>
</li>
</ul>
<strong><p class="rubric">Functions (namespace qi)</p>
</strong><ul class="simple">
<a class="reference internal" href="#qi::PromiseNoop__X">qi::PromiseNoop</a></ul>
</dl>
</li>
<li><p class="first">namespace qi::FutureSync&lt;T&gt;</p>
<dl class="docutils">
<strong><p class="rubric">Functions (namespace qi::FutureSync&lt;T&gt;)</p>
</strong><ul class="simple">
<a class="reference internal" href="#qi::FutureSync:T:::isCancelableC">qi::FutureSync&lt;T&gt;::isCancelable</a><p><a class="reference internal" href="#qi::FutureSync:T:::assign-operator__FutureSync:T:CR">qi::FutureSync&lt;T&gt;::operator=</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::lt-operator__FutureSync:T:CRC">qi::FutureSync&lt;T&gt;::operator&lt;</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::isFinishedC">qi::FutureSync&lt;T&gt;::isFinished</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::FutureSync">qi::FutureSync&lt;T&gt;::FutureSync</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::isCanceledC">qi::FutureSync&lt;T&gt;::isCanceled</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::_connect__boost::function:void:CR">qi::FutureSync&lt;T&gt;::_connect</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::castto-Future:T:-operator">qi::FutureSync&lt;T&gt;::operator Future&lt;T&gt;</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::connect__ConnectionCR">qi::FutureSync&lt;T&gt;::connect</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::hasValue__iC">qi::FutureSync&lt;T&gt;::hasValue</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::hasError__iC">qi::FutureSync&lt;T&gt;::hasError</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::castto-typename-Future:T:::ValueTypeCastCR-operatorC">qi::FutureSync&lt;T&gt;::operator const typename Future&lt;T&gt;::ValueTypeCast&amp;</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::error__iC">qi::FutureSync&lt;T&gt;::error</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::wait__iC">qi::FutureSync&lt;T&gt;::wait</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::async">qi::FutureSync&lt;T&gt;::async</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::isRunningC">qi::FutureSync&lt;T&gt;::isRunning</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::cancel">qi::FutureSync&lt;T&gt;::cancel</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::value__iC">qi::FutureSync&lt;T&gt;::value</a></p>
<p><a class="reference internal" href="#qi::FutureSync:T:::~FutureSync">qi::FutureSync&lt;T&gt;::~FutureSync</a></p>
</ul>
</dl>
</li>
<li><p class="first">namespace qi::Future&lt;T&gt;</p>
<dl class="docutils">
<strong><p class="rubric">Functions (namespace qi::Future&lt;T&gt;)</p>
</strong><ul class="simple">
<a class="reference internal" href="#qi::Future:T:::Future">qi::Future&lt;T&gt;::Future</a><p><a class="reference internal" href="#qi::Future:T:::lt-operator__Future:T:CRC">qi::Future&lt;T&gt;::operator&lt;</a></p>
<p><a class="reference internal" href="#qi::Future:T:::value__iC">qi::Future&lt;T&gt;::value</a></p>
<p><a class="reference internal" href="#qi::Future:T:::cancel">qi::Future&lt;T&gt;::cancel</a></p>
<p><a class="reference internal" href="#qi::Future:T:::isRunningC">qi::Future&lt;T&gt;::isRunning</a></p>
<p><a class="reference internal" href="#qi::Future:T:::isCancelableC">qi::Future&lt;T&gt;::isCancelable</a></p>
<p><a class="reference internal" href="#qi::Future:T:::isFinishedC">qi::Future&lt;T&gt;::isFinished</a></p>
<p><a class="reference internal" href="#qi::Future:T:::hasError__iC">qi::Future&lt;T&gt;::hasError</a></p>
<p><a class="reference internal" href="#qi::Future:T:::error__iC">qi::Future&lt;T&gt;::error</a></p>
<p><a class="reference internal" href="#qi::Future:T:::wait__iC">qi::Future&lt;T&gt;::wait</a></p>
<p><a class="reference internal" href="#qi::Future:T:::hasValue__iC">qi::Future&lt;T&gt;::hasValue</a></p>
<p><a class="reference internal" href="#qi::Future:T:::assign-operator__Future:T:CR">qi::Future&lt;T&gt;::operator=</a></p>
<p><a class="reference internal" href="#qi::Future:T:::sync">qi::Future&lt;T&gt;::sync</a></p>
<p><a class="reference internal" href="#qi::Future:T:::isCanceledC">qi::Future&lt;T&gt;::isCanceled</a></p>
<p><a class="reference internal" href="#qi::Future:T:::eq-operator__Future:T:CR">qi::Future&lt;T&gt;::operator==</a></p>
<p><a class="reference internal" href="#qi::Future:T:::_connect__boost::function:void:CR">qi::Future&lt;T&gt;::_connect</a></p>
<p><a class="reference internal" href="#qi::Future:T:::connectWithStrand__qi::StrandP.boost::function:void__X:CR">qi::Future&lt;T&gt;::connectWithStrand</a></p>
<p><a class="reference internal" href="#qi::Future:T:::connect__AFCR.FutureCallbackType">qi::Future&lt;T&gt;::connect</a></p>
<p><a class="reference internal" href="#qi::Future:T:::castto-ValueTypeCastCR-operatorC">qi::Future&lt;T&gt;::operator const ValueTypeCast&amp;</a></p>
<p><a class="reference internal" href="#qi::Future:T:::impl">qi::Future&lt;T&gt;::impl</a></p>
</ul>
</dl>
</li>
<li><p class="first">namespace qi::Promise&lt;T&gt;</p>
<dl class="docutils">
<strong><p class="rubric">Functions (namespace qi::Promise&lt;T&gt;)</p>
</strong><ul class="simple">
<a class="reference internal" href="#qi::Promise:T:::setValue__ValueTypeCR">qi::Promise&lt;T&gt;::setValue</a><p><a class="reference internal" href="#qi::Promise:T:::isCancelRequested">qi::Promise&lt;T&gt;::isCancelRequested</a></p>
<p><a class="reference internal" href="#qi::Promise:T:::Promise__FutureCallbackType">qi::Promise&lt;T&gt;::Promise</a></p>
<p><a class="reference internal" href="#qi::Promise:T:::setCanceled">qi::Promise&lt;T&gt;::setCanceled</a></p>
<p><a class="reference internal" href="#qi::Promise:T:::futureC">qi::Promise&lt;T&gt;::future</a></p>
<p><a class="reference internal" href="#qi::Promise:T:::trigger">qi::Promise&lt;T&gt;::trigger</a></p>
<p><a class="reference internal" href="#qi::Promise:T:::reset">qi::Promise&lt;T&gt;::reset</a></p>
<p><a class="reference internal" href="#qi::Promise:T:::setError__ssCR">qi::Promise&lt;T&gt;::setError</a></p>
<p><a class="reference internal" href="#qi::Promise:T:::value">qi::Promise&lt;T&gt;::value</a></p>
</ul>
</dl>
</li>
</ul>
</dl>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<div class="section" id="qi-future">
<h3>qi::Future<a class="headerlink" href="#qi-future" title="Permalink to this headline">¶</a></h3>
<p>A <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a> provides a way to wait for and get the result of an asynchronous
operation. It is the receiving end of a <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Future</span></tt></a> - <a class="reference internal" href="#qi::Promise" title="qi::Promise"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Promise</span></tt></a> pair.</p>
<p><em>Future</em> is templated by the type of the underlying value. <em>void</em> is permitted.</p>
<div class="section" id="the-different-states-of-a-future">
<h4>The different states of a Future<a class="headerlink" href="#the-different-states-of-a-future" title="Permalink to this headline">¶</a></h4>
<p>A future can be in multiple states represented by <tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureState</span></tt>:</p>
<ul class="simple">
<li>FutureState_None: The Future is not tied to a Promise, and will never change
state.</li>
<li>FutureState_Running: The future is tied to a Promise, and the asynchronous
operation has not finished yet.</li>
<li>FutureState_Canceled: The operation was successfully canceled.</li>
<li>FutureState_FinishedWithError: The operation finished with an error.</li>
<li>FutureState_FinishedWithValue: The operation finished and its return value is
available.</li>
</ul>
</div>
<div class="section" id="getting-the-state-and-waiting-for-a-future">
<h4>Getting the state and waiting for a Future<a class="headerlink" href="#getting-the-state-and-waiting-for-a-future" title="Permalink to this headline">¶</a></h4>
<p>There are multiple ways to handle a future. The first is to use the
<a class="reference internal" href="#qi::Future:T:::value__iC" title="qi::Future&lt;T&gt;::value"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Future&lt;T&gt;::value</span></tt></a> method. In that case, the call will block until the
Future leaves the <em>running</em> state.  Then if a value if available, it will be
returned. Otherwise a <tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureException</span></tt> will be raised:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">someOperation</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">callIt</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">someOperation</span><span class="p">().</span><span class="n">value</span><span class="p">();</span> <span class="c1">// wait, then get the value or throw</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you do not wish to wait forever, or want to handle Future error without
catching an exception, you can use <a class="reference internal" href="#qi::Future:T:::wait__iC" title="qi::Future&lt;T&gt;::wait"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future&lt;T&gt;::wait</span></tt></a> (timeout):
this function waits at most the specified time in milliseconds, and return
a <tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureState</span></tt>. You can then safely call <a class="reference internal" href="#qi::Future:T:::value__iC" title="qi::Future&lt;T&gt;::value"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future&lt;T&gt;::value</span></tt></a> or
<a class="reference internal" href="#qi::Future:T:::error__iC" title="qi::Future&lt;T&gt;::error"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future&lt;T&gt;::error</span></tt></a>, if future is in state <tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureState_FinishedWithValue</span></tt> or
<tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureState_FinishedWithError</span></tt> respectively:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">someOperation</span><span class="p">();</span>
<span class="k">switch</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="p">{</span>
   <span class="k">case</span> <span class="n">FutureState_Running</span>:
     <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Still not ready&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="k">break</span><span class="p">;</span>
   <span class="k">case</span> <span class="n">FutureState_Canceled</span>:
     <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Canceled&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="k">break</span><span class="p">;</span>
   <span class="k">case</span> <span class="n">FutureState_FinishedWithError</span>:
     <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">error</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="k">break</span><span class="p">;</span>
   <span class="k">case</span> <span class="n">FutureState_FinishedWithValue</span>:
     <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Value: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="future-notification">
<h4>Future notification<a class="headerlink" href="#future-notification" title="Permalink to this headline">¶</a></h4>
<p>Alternatively, you can get notified of Future completion asynchronously using
<a class="reference internal" href="#qi::Future:T:::connect__AFCR.FutureCallbackType" title="qi::Future&lt;T&gt;::connect"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future&lt;T&gt;::connect</span></tt></a>. This function accepts a callback function or
functor with signature <tt class="docutils literal"><span class="pre">void</span> <span class="pre">(qi::Future&lt;T&gt;</span> <span class="pre">f)</span></tt>.</p>
<p>The Future guarantees you that your callback function will be called once and
only once, when or if the Future leaves the <em>Running</em> state (that is, enters
one of <em>Canceled</em>, <em>FinishedWithError</em> or <em>FinishedWithValue</em>):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">myCallback</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">FutureState</span> <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="c1">// will return immediately, Future has finished.</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{...}</span>
<span class="p">}</span>

<span class="c1">// ...</span>
<span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">someOperation</span><span class="p">();</span>
<span class="n">f</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myCallback</span><span class="p">);</span>
</pre></div>
</div>
<p>The callback is always invoked asynchronously (in the promise thread or in any
thread, depending on the promise type) unless specified otherwise in the
connect.</p>
<p id="future-connect">connect() accepts extra arguments after the callback: values or placeholders
that will be bound to the call(similarly to how <tt class="docutils literal"><span class="pre">boost::bind</span></tt> works). If
the first argument is a <tt class="docutils literal"><span class="pre">boost::weak_ptr</span></tt>, or inherits from <a class="reference internal" href="trackable.html#qi::Trackable" title="qi::Trackable"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Trackable</span></tt></a>,
then the callback will not be called if the weak_ptr cannot be locked, or
if the Trackable was destroyed:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">onOpFinished</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNumber</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">safe_async_op</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNumber</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">someOperation</span><span class="p">();</span>
  <span class="c1">// This version will keep foo alive at least until the Future finished</span>
  <span class="n">future</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">onOpFinished</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">opNumber</span><span class="p">);</span>
  <span class="c1">// This version is safe in case foo is destroyed before the Future finishes.</span>
  <span class="n">future</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Foo</span><span class="o">::</span><span class="n">onOpFinished</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">_1</span><span class="p">,</span> <span class="n">opNumber</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="future-cancellation">
<h4>Future cancellation<a class="headerlink" href="#future-cancellation" title="Permalink to this headline">¶</a></h4>
<p>An async operation that returns a Future can support cancellation.  To check if
a future you have can be canceled, use <tt class="xref cpp cpp-guess docutils literal"><span class="pre">isCancelable</span></tt>.</p>
<p>If <tt class="xref cpp cpp-guess docutils literal"><span class="pre">isCancelable</span></tt> returns true, you can try to abort the operation by calling
<tt class="xref cpp cpp-guess docutils literal"><span class="pre">cancel</span></tt>. Depending on the operation and on the timing of your call, your
cancel request might be ignored (for example, if it is received too late and a
value is already available). But you can expect the Future to hastily leave the
<em>Running</em> state one way or an other.</p>
<p>The property <em>cancellable</em> of a future is defined at the construction of the
promise. You rarely need to check if a future is cancellable, as the
specification of the function which returned it should tell whether it is
cancellable or not.</p>
</div>
</div>
<div class="section" id="qi-promise">
<h3>qi::Promise<a class="headerlink" href="#qi-promise" title="Permalink to this headline">¶</a></h3>
<p id="api-promise">A <a class="reference internal" href="#qi::Promise" title="qi::Promise"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Promise</span></tt></a> is an object that can create and satisfy a <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Future</span></tt></a>.
Like <em>Future</em>, it has shared semantics (all copies of a Promise represent the
same object). The next example illustrates it&#8217;s basic use case:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myFunctionReturningAFuture</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">Promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">;</span>
  <span class="c1">// start an asynchronous operation, holding the promise</span>
  <span class="c1">// note that starting threads like that is bad practice, use qi::async</span>
  <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">someAsynchronousOp</span><span class="p">,</span> <span class="n">promise</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">promise</span><span class="p">.</span><span class="n">future</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">someAsynchronousOp</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">Promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">performSomeTask</span><span class="p">();</span>
    <span class="n">promise</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">promise</span><span class="p">.</span><span class="n">setError</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In plain English:</p>
<ul class="simple">
<li>Create a <a class="reference internal" href="#qi::Promise" title="qi::Promise"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise</span></tt></a> and return the <tt class="docutils literal"><span class="pre">future()</span></tt> obtained with
<a class="reference internal" href="#qi::Promise:T:::futureC" title="qi::Promise&lt;T&gt;::future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise::future</span></tt></a>.</li>
<li>Transmit the <em>Promise</em> to the asynchronously executing code.</li>
<li>Notify of successful completion with <a class="reference internal" href="#qi::Promise:T:::setValue__ValueTypeCR" title="qi::Promise&lt;T&gt;::setValue"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise::setValue</span></tt></a> or
<a class="reference internal" href="#qi::Promise:T:::setError__ssCR" title="qi::Promise&lt;T&gt;::setError"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise::setError</span></tt></a>.</li>
<li>Only one of the two functions above must be called, and only once per
<a class="reference internal" href="#qi::Promise" title="qi::Promise"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise</span></tt></a>.</li>
</ul>
<div class="section" id="supporting-cancellation">
<h4>Supporting cancellation<a class="headerlink" href="#supporting-cancellation" title="Permalink to this headline">¶</a></h4>
<p>If your asynchronous operation can be canceled, you must provide a callback
with signature <tt class="docutils literal"><span class="pre">void(qi::Promise&lt;T&gt;)</span></tt> to the <a class="reference internal" href="#qi::Promise" title="qi::Promise"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise</span></tt></a> constructor. You can
provide <a class="reference internal" href="#qi::PromiseNoop__X" title="qi::PromiseNoop"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::PromiseNoop</span></tt></a> if you don&#8217;t have any specific action to do upon
cancellation.</p>
<p>This callback will then be called if a cancellation request is received by a
connected <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a>. This callback is expected to ensure that the connected
<a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a> hastily leaves the <em>Running</em> state, by calling one of
<a class="reference internal" href="#qi::Promise:T:::setValue__ValueTypeCR" title="qi::Promise&lt;T&gt;::setValue"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise::setValue</span></tt></a>, <a class="reference internal" href="#qi::Promise:T:::setError__ssCR" title="qi::Promise&lt;T&gt;::setError"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise::setError</span></tt></a> and <a class="reference internal" href="#qi::Promise:T:::setCanceled" title="qi::Promise&lt;T&gt;::setCanceled"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise::setCanceled</span></tt></a>.
However this call does not have to be made synchronously in the cancellation
callback.</p>
<p>If you used <a class="reference internal" href="#qi::PromiseNoop__X" title="qi::PromiseNoop"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::PromiseNoop</span></tt></a>, you can rely on <a class="reference internal" href="#qi::Promise:T:::isCancelRequested" title="qi::Promise&lt;T&gt;::isCancelRequested"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Promise::isCancelRequested</span></tt></a> to
check at a given point if the user requested a cancellation.</p>
<p>You can see <a class="reference internal" href="#future-usage-cancel"><em>an example with cancellation support</em></a> at
the end of this document.</p>
</div>
<div class="section" id="controlling-callback-execution">
<h4>Controlling callback execution<a class="headerlink" href="#controlling-callback-execution" title="Permalink to this headline">¶</a></h4>
<p>When one of the three state-changing functions listed above is called on
a <em>Promise</em>, callbacks registered to the connected <em>Future</em> will be
invoked. You can control whether this invocation is made synchronously,
or asynchronously using a thread from an internal thread pool, by passing
one of <em>FutureCallbackType_Sync</em> and <em>FutureCallbackType_Async</em> to the
<em>Promise</em> constructor.</p>
</div>
</div>
<div class="section" id="qi-futuresync">
<h3>qi::FutureSync<a class="headerlink" href="#qi-futuresync" title="Permalink to this headline">¶</a></h3>
<p><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::FutureSync</span></tt> is a lightweight wrapper on top of
<tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::Future</span></tt> that will wait on the <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a> in its destructor
if the <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a> was ignored by the user.</p>
<p>It is intended to be used as a way to provide a default apparent
synchronous-blocking behavior to a function, that can be changed into
an asynchronous behavior by handling the resulting <a class="reference internal" href="#qi::FutureSync" title="qi::FutureSync"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureSync</span></tt></a>.</p>
<div class="section" id="returning-a-futuresync">
<h4>Returning a FutureSync<a class="headerlink" href="#returning-a-futuresync" title="Permalink to this headline">¶</a></h4>
<p>You can simply change the returned type from <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a> to <a class="reference internal" href="#qi::FutureSync" title="qi::FutureSync"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureSync</span></tt></a> in the
<a class="reference internal" href="#api-promise"><em>basic example</em></a>. The returned <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a> will transparently
convert to a <a class="reference internal" href="#qi::FutureSync" title="qi::FutureSync"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureSync</span></tt></a>.</p>
</div>
<div class="section" id="calling-a-function-returning-a-futuresync">
<h4>Calling a function returning a FutureSync<a class="headerlink" href="#calling-a-function-returning-a-futuresync" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#qi::FutureSync" title="qi::FutureSync"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureSync</span></tt></a> follow this simple rule: The destructor will call
<a class="reference internal" href="#qi::Future:T:::wait__iC" title="qi::Future&lt;T&gt;::wait"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future::wait</span></tt></a> from its destructor, unless:</p>
<ul class="simple">
<li>It is copied into another <a class="reference internal" href="#qi::Future" title="qi::Future"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">Future</span></tt></a> or <a class="reference internal" href="#qi::FutureSync" title="qi::FutureSync"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureSync</span></tt></a></li>
<li><a class="reference internal" href="#qi::FutureSync:T:::async" title="qi::FutureSync&lt;T&gt;::async"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureSync::async</span></tt></a> or any of the Future function is called (<tt class="xref cpp cpp-guess docutils literal"><span class="pre">wait</span></tt>,
<tt class="xref cpp cpp-guess docutils literal"><span class="pre">connect</span></tt>, ...)</li>
</ul>
<p><a class="reference internal" href="#qi::FutureSync" title="qi::FutureSync"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">FutureSync</span></tt></a> also has a cast operator that allows you to use the returned value
transparently.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">qi</span><span class="o">::</span><span class="n">FutureSync</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">someFunction</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">someFunction</span><span class="p">();</span> <span class="c1">// will wait</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">FutureSync</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">someFunction</span><span class="p">();</span> <span class="c1">// will wait at end of scope</span>
  <span class="n">someFunction</span><span class="p">().</span><span class="n">async</span><span class="p">();</span>                 <span class="c1">// will not wait</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">someFunction</span><span class="p">();</span>    <span class="c1">// will not wait</span>
  <span class="n">someFunction</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>                 <span class="c1">// will wait, because of value()</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">someFunction</span><span class="p">();</span>               <span class="c1">// will wait, does the same as</span>
                                          <span class="c1">// value(), may throw on error</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementing-an-asynchronous-function">
<span id="future-usage"></span><h3>Implementing an asynchronous function<a class="headerlink" href="#implementing-an-asynchronous-function" title="Permalink to this headline">¶</a></h3>
<div class="section" id="simple-implementation">
<h4>Simple implementation<a class="headerlink" href="#simple-implementation" title="Permalink to this headline">¶</a></h4>
<p>Here is an example of an asynchronous function implementation that supports
cancellation.</p>
<p>Let&#8217;s implement this class and make <tt class="docutils literal"><span class="pre">calculate()</span></tt> asynchronous.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Worker</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">calculate</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>First, <tt class="docutils literal"><span class="pre">calculate</span></tt> must return a future and we must create a function to do
the actual work.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;qi/future.hpp&gt;</span>

<span class="k">class</span> <span class="nc">Worker</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">calculate</span><span class="p">();</span>

  <span class="nl">private:</span>
    <span class="kt">void</span> <span class="nf">doWork</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">Promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For the sake of this example, we&#8217;ll use a simple function to simulate work:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Worker</span><span class="o">::</span><span class="n">doWork</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">Promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">qi</span><span class="o">::</span><span class="n">os</span><span class="o">::</span><span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// working...</span>
    <span class="n">acc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">promise</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">acc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And then, we must call this function asynchronously and return the
corresponding future:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Worker</span><span class="o">::</span><span class="n">calculate</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">Promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">;</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Worker</span><span class="o">::</span><span class="n">doWork</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">promise</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">promise</span><span class="p">.</span><span class="n">future</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, <tt class="docutils literal"><span class="pre">calculate</span></tt> is asynchronous! But this isn&#8217;t useful at all, our code is
more complex and this could have been done just by calling <a class="reference internal" href="eventloop.html#qi::async__boost::function:R:.uint64_t" title="qi::async"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::async</span></tt></a>. What we
can do now is to support cancellation so that one can call <tt class="xref cpp cpp-guess docutils literal"><span class="pre">cancel()</span></tt> on the
returned future to abort the action.</p>
</div>
<div class="section" id="cancellation-support">
<span id="future-usage-cancel"></span><h4>Cancellation support<a class="headerlink" href="#cancellation-support" title="Permalink to this headline">¶</a></h4>
<p>Promises are cancellable when they are given a cancellation callback at
construction. You usually don&#8217;t need this callback so you can just pass the
no-operation callback.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">qi</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Worker</span><span class="o">::</span><span class="n">calculate</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">Promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">PromiseNoop</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="n">qi</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Worker</span><span class="o">::</span><span class="n">doWork</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">promise</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">promise</span><span class="p">.</span><span class="n">future</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">doWork()</span></tt> can now check if the future has been cancelled.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Worker</span><span class="o">::</span><span class="n">doWork</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">Promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">promise</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">promise</span><span class="p">.</span><span class="n">isCancelRequested</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cancel requested&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">promise</span><span class="p">.</span><span class="n">setCanceled</span><span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">qi</span><span class="o">::</span><span class="n">os</span><span class="o">::</span><span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// working...</span>
    <span class="n">acc</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">promise</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">acc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="E_qi::FutureState">
<!--[E_qi::FutureState]--><em>enum</em> <tt class="descname">qi::FutureState</tt><a class="headerlink" href="#E_qi::FutureState" title="Permalink to this definition">¶</a></dt>
<dd><table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="10%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Value</th>
<th class="head">Brief</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">FutureState_None</span></tt></td>
<td></td>
<td>Future is not tied to a promise. </td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">FutureState_Running</span></tt></td>
<td></td>
<td>Operation pending. </td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">FutureState_Canceled</span></tt></td>
<td></td>
<td>The future has been canceled. </td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">FutureState_FinishedWithError</span></tt></td>
<td></td>
<td>The operation is finished with an error. </td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">FutureState_FinishedWithValue</span></tt></td>
<td></td>
<td>The operation is finished with a value. </td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="section" id="qi-future-class-reference">
<h3>qi::Future Class Reference<a class="headerlink" href="#qi-future-class-reference" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p> <a class="reference external" href="#detailed-description"><tt class="docutils literal"><span class="pre">More...</span></tt></a></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;qi/future.hpp&gt;</span>
</pre></div>
</div>
<ul class="simple">
</ul>
</div>
<div class="section" id="public-functions">
<h4>Public Functions<a class="headerlink" href="#public-functions" title="Permalink to this headline">¶</a></h4>
<dl class="function function-index">
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::Future"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Future</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::Future__Future:T:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Future</span></tt></a></tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big></dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::eq-operator__Future:T:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator==</span></tt></a></tt><big>(</big>const Future&lt;T&gt;&amp; <em>other</em><big>)</big></dt>
<dt>
<span>Future&lt;T&gt;&amp;</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::assign-operator__Future:T:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator=</span></tt></a></tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big></dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::lt-operator__Future:T:CRC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator&lt;</span></tt></a></tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big> const</dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::Future__ValueTypeCR.FutureCallbackType"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Future</span></tt></a></tt><big>(</big>const ValueType&amp; <em>v</em>, FutureCallbackType <em>async</em><big>)</big></dt>
<dt>
<span>const ValueType&amp;</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::value__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">value</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::castto-ValueTypeCastCR-operatorC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator</span> <span class="pre">const</span> <span class="pre">ValueTypeCast&amp;</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>FutureState</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::wait__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">wait</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>FutureState</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::wait__qi::DurationC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">wait</span></tt></a></tt><big>(</big>qi::Duration <em>duration</em><big>)</big> const</dt>
<dt>
<span>FutureState</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::wait__qi::SteadyClock::time_pointC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">wait</span></tt></a></tt><big>(</big>qi::SteadyClock::time_point <em>timepoint</em><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::isFinishedC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isFinished</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::isRunningC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isRunning</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::isCanceledC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isCanceled</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::hasError__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">hasError</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::hasValue__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">hasValue</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>const std::string&amp;</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::error__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">error</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>FutureSync&lt;T&gt;</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::sync"><tt class="xref cpp cpp-func docutils literal"><span class="pre">sync</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::cancel"><tt class="xref cpp cpp-func docutils literal"><span class="pre">cancel</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::isCancelableC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isCancelable</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::connect__AFCR.FutureCallbackType"><tt class="xref cpp cpp-func docutils literal"><span class="pre">connect</span></tt></a></tt><big>(</big>const AF&amp; <em>fun</em>, FutureCallbackType <em>type</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::connect__FUNCTYPE.ARG0.X.FutureCallbackType"><tt class="xref cpp cpp-func docutils literal"><span class="pre">connect</span></tt></a></tt><big>(</big>FUNCTYPE <em>fun</em>, ARG0 <em>tracked</em>, <em>...</em>, FutureCallbackType <em>type</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::connectWithStrand__qi::StrandP.boost::function:void__X:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">connectWithStrand</span></tt></a></tt><big>(</big>qi::Strand* <em>strand</em>, const boost::function&lt;void(const Future&lt;T&gt;&amp;)&gt;&amp; <em>cb</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::_connect__boost::function:void:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">_connect</span></tt></a></tt><big>(</big>const boost::function&lt;void()&gt;&amp; <em>s</em><big>)</big></dt>
<dt>
<span>boost::shared_ptr&lt;detail::FutureBaseTyped&lt;T&gt;&gt;</span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::impl"><tt class="xref cpp cpp-func docutils literal"><span class="pre">impl</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::Future:T:::Future__boost::shared_ptr:detail::FutureBaseTyped:T::"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Future</span></tt></a></tt><big>(</big>boost::shared_ptr&lt;detail::FutureBaseTyped&lt;T&gt;&gt; <em>p</em><big>)</big></dt>
</dl>

</div>
<div class="section" id="types">
<h4>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h4>
<dl class="type">
<dt id="TPD_qi::Future::ValueType">
<!--[TPD_qi::Future::ValueType]--><span><em>typedef </em>detail::FutureType&lt; T &gt;::type</span> <span>ValueType</span><a class="headerlink" href="#TPD_qi::Future::ValueType" title="Permalink to this definition">¶</a></dt>
<span>

        

        </span><dt id="TPD_qi::Future::ValueTypeCast">
<span><em>typedef </em>detail::FutureType&lt; T &gt;::typecast</span> <span>ValueTypeCast</span><a class="headerlink" href="#TPD_qi::Future::ValueTypeCast" title="Permalink to this definition">¶</a></dt>
<span>

        

        </span><dt id="TPD_qi::Future::Connection">
<span><em>typedef </em>boost::function&lt; void(Future&lt; T &gt;) &gt;</span> <span>Connection</span><a class="headerlink" href="#TPD_qi::Future::Connection" title="Permalink to this definition">¶</a></dt>
<span>

        

        </span></dl>

</div>
<div class="section" id="detailed-description">
<h4>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h4>
<p>Class that represents a value that will be set later in time.</p>
</div>
<div class="section" id="function-documentation">
<h4>Function Documentation<a class="headerlink" href="#function-documentation" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="qi::Future:T:::Future">
 <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">Future</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Future:T:::Future" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::Future__Future:T:CR">
 <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">Future</tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big><a class="headerlink" href="#qi::Future:T:::Future__Future:T:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::eq-operator__Future:T:CR">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">operator==</tt><big>(</big>const Future&lt;T&gt;&amp; <em>other</em><big>)</big><a class="headerlink" href="#qi::Future:T:::eq-operator__Future:T:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::assign-operator__Future:T:CR">
Future&lt;T&gt;&amp; <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">operator=</tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big><a class="headerlink" href="#qi::Future:T:::assign-operator__Future:T:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::lt-operator__Future:T:CRC">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">operator&lt;</tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::lt-operator__Future:T:CRC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::Future__ValueTypeCR.FutureCallbackType">
 <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">Future</tt><big>(</big>const ValueType&amp; <em>v</em>, FutureCallbackType <em>async</em> = FutureCallbackType_Async<big>)</big><a class="headerlink" href="#qi::Future:T:::Future__ValueTypeCR.FutureCallbackType" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a Future that already contains a value.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::value__iC">
const ValueType&amp; <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">value</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::value__iC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em>Return the value associated to a Future. </p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msecs</strong> &#8211; timeout </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the value</p>
</td>
</tr>
</tbody>
</table>
<p>This function can throw for many reason:
wait timeoutuser errorfuture canceled</p>
<p>if an error is set, then value throw a FutureUserException, others errors are FutureException.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::castto-ValueTypeCastCR-operatorC">
 <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">operator</tt> const ValueTypeCast&amp;<big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::castto-ValueTypeCastCR-operatorC" title="Permalink to this definition">¶</a></dt>
<dd><p>same as value() with an infinite timeout.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::wait__iC">
FutureState <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">wait</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::wait__iC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msecs</strong> &#8211; Maximum time to wait in milliseconds, 0 means return immediately. </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a FutureState corresponding to the state of the future. </p>
</td>
</tr>
</tbody>
</table>
<p>Wait for future to contain a value or an error</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::wait__qi::DurationC">
FutureState <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">wait</tt><big>(</big><a class="reference external" href="clock.html#TPD_qi::Duration">qi::Duration</a> <em>duration</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::wait__qi::DurationC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>duration</strong> &#8211; Maximum time to wait </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a FutureState corresponding to the state of the future. </p>
</td>
</tr>
</tbody>
</table>
<p>Wait for future to contain a value or an error</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::wait__qi::SteadyClock::time_pointC">
FutureState <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">wait</tt><big>(</big><a class="reference external" href="clock.html#TPD_qi::SteadyClock::time_point">qi::SteadyClock::time_point</a> <em>timepoint</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::wait__qi::SteadyClock::time_pointC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>timepoint</strong> &#8211; Time until which we can wait </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a FutureState corresponding to the state of the future. </p>
</td>
</tr>
</tbody>
</table>
<p>Wait for future to contain a value or an error</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::isFinishedC">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">isFinished</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::isFinishedC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the future is finished do not throw </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::isRunningC">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">isRunning</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::isRunningC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the future is running do not throw </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::isCanceledC">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">isCanceled</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::isCanceledC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the future has been canceled This means that the future has been fully canceled, not that a cancel was requested. do not throw </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::hasError__iC">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">hasError</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::hasError__iC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msecs</strong> &#8211; timeout </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">true if the future has an error. throw in the following case:
timeout 
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::hasValue__iC">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">hasValue</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::hasValue__iC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msecs</strong> &#8211; timeout </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">true if the future has a value. throw in the following case:
timeout 
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::error__iC">
const std::string&amp; <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">error</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::error__iC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msecs</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the error throw on timeout throw if the future do not have an actual error. </p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::sync">
FutureSync&lt;T&gt; <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">sync</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Future:T:::sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the future sync Should not be useful, use wait().</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::cancel">
void <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Future:T:::cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>cancel() the asynchronous operation if possible Exact effect is controlled by the cancel implementation, but it is expected to set a value or an error to the Future as fast as possible. Note that cancelation may be asynchronous.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::isCancelableC">
bool <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">isCancelable</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Future:T:::isCancelableC" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the future can be canceled. This does not mean that cancel will succeed. </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::connect__AFCR.FutureCallbackType">
void <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">connect</tt><big>(</big>const AF&amp; <em>fun</em>, FutureCallbackType <em>type</em> = FutureCallbackType_Async<big>)</big><a class="headerlink" href="#qi::Future:T:::connect__AFCR.FutureCallbackType" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a callback function that will be called once when the Future finishes (that is, switches from running to an other state).</p>
<p>If type is sync, connect may block and call the callback synchronously if the future is already set.</p>
<p>It guaranteed that your callback will be called exactly once (unless the promise is never set or the promise is reset, which is deprecated).</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::connect__FUNCTYPE.ARG0.X.FutureCallbackType">
void <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">connect</tt><big>(</big>FUNCTYPE <em>fun</em>, ARG0 <em>tracked</em>, <em>...</em>, FutureCallbackType <em>type</em> = FutureCallbackType_Async<big>)</big><a class="headerlink" href="#qi::Future:T:::connect__FUNCTYPE.ARG0.X.FutureCallbackType" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a callback with binding and tracking support.</p>
<p>If the first argument is a weak_ptr or a pointer inheriting from qi::Trackable, the callback will not be called if tracked object was destroyed.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Future:T:::connectWithStrand__qi::StrandP.boost::function:void__X:CR">
void <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">connectWithStrand</tt><big>(</big>qi::Strand* <em>strand</em>, const boost::function&lt;void(const Future&lt;T&gt;&amp;)&gt;&amp; <em>cb</em><big>)</big><a class="headerlink" href="#qi::Future:T:::connectWithStrand__qi::StrandP.boost::function:void__X:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::_connect__boost::function:void:CR">
void <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">_connect</tt><big>(</big>const boost::function&lt;void()&gt;&amp; <em>s</em><big>)</big><a class="headerlink" href="#qi::Future:T:::_connect__boost::function:void:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::impl">
boost::shared_ptr&lt;detail::FutureBaseTyped&lt;T&gt;&gt; <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">impl</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Future:T:::impl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::Future:T:::Future__boost::shared_ptr:detail::FutureBaseTyped:T::">
 <tt class="descclassname">qi::Future&lt;T&gt;::</tt><tt class="descname">Future</tt><big>(</big>boost::shared_ptr&lt;detail::FutureBaseTyped&lt;T&gt;&gt; <em>p</em><big>)</big><a class="headerlink" href="#qi::Future:T:::Future__boost::shared_ptr:detail::FutureBaseTyped:T::" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="qi-promise-class-reference">
<h3>qi::Promise Class Reference<a class="headerlink" href="#qi-promise-class-reference" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p> <a class="reference external" href="#detailed-description"><tt class="docutils literal"><span class="pre">More...</span></tt></a></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;qi/future.hpp&gt;</span>
</pre></div>
</div>
<ul>
<li><strong>Inherited by: </strong><tt class="docutils literal"><span class="pre">qi::detail::DelayedPromise&lt;</span> <span class="pre">T</span> <span class="pre">&gt;</span></tt></li>
</ul>
</div>
<div class="section" id="public-functions">
<h4>Public Functions<a class="headerlink" href="#public-functions" title="Permalink to this headline">¶</a></h4>
<dl class="function function-index">
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::Promise__FutureCallbackType"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Promise</span></tt></a></tt><big>(</big>FutureCallbackType <em>async</em><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::Promise__boost::function:void__X:.FutureCallbackType"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Promise</span></tt></a></tt><big>(</big>boost::function&lt;void(qi::Promise&lt;T&gt;)&gt; <em>cancelCallback</em>, FutureCallbackType <em>async</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::setValue__ValueTypeCR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">setValue</span></tt></a></tt><big>(</big>const ValueType&amp; <em>value</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::setError__ssCR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">setError</span></tt></a></tt><big>(</big>const std::string&amp; <em>msg</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::setCanceled"><tt class="xref cpp cpp-func docutils literal"><span class="pre">setCanceled</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::isCancelRequested"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isCancelRequested</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::reset"><tt class="xref cpp cpp-func docutils literal"><span class="pre">reset</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>Future&lt;T&gt;</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::futureC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">future</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>ValueType&amp;</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::value"><tt class="xref cpp cpp-func docutils literal"><span class="pre">value</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::Promise:T:::trigger"><tt class="xref cpp cpp-func docutils literal"><span class="pre">trigger</span></tt></a></tt><big>(</big><big>)</big></dt>
</dl>

</div>
<div class="section" id="types">
<h4>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h4>
<dl class="type">
<dt id="TPD_qi::Promise::ValueType">
<!--[TPD_qi::Promise::ValueType]--><span><em>typedef </em>detail::FutureType&lt; T &gt;::type</span> <span>ValueType</span><a class="headerlink" href="#TPD_qi::Promise::ValueType" title="Permalink to this definition">¶</a></dt>
<span>

        

        </span></dl>

</div>
<div class="section" id="detailed-description">
<h4>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h4>
<p>A Promise is used to create and satisfy a Future.</p>
</div>
<div class="section" id="function-documentation">
<h4>Function Documentation<a class="headerlink" href="#function-documentation" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="qi::Promise:T:::Promise__FutureCallbackType">
 <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">Promise</tt><big>(</big>FutureCallbackType <em>async</em> = FutureCallbackType_Async<big>)</big><a class="headerlink" href="#qi::Promise:T:::Promise__FutureCallbackType" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Brief: </em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>async</strong> &#8211; specify how callbacks registered with Future::connect are called: synchronously from the Promise setter, or asynchronously from a thread pool. </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a standard promise.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::Promise__boost::function:void__X:.FutureCallbackType">
 <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">Promise</tt><big>(</big>boost::function&lt;void(qi::Promise&lt;T&gt;)&gt; <em>cancelCallback</em>, FutureCallbackType <em>async</em> = FutureCallbackType_Async<big>)</big><a class="headerlink" href="#qi::Promise:T:::Promise__boost::function:void__X:.FutureCallbackType" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a canceleable promise. If Future&lt;T&gt;::cancel is invoked, onCancel() will be called. It is expected to call setValue(), setError() or setCanceled() as quickly as possible, but can do so in an asynchronous way.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::setValue__ValueTypeCR">
void <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">setValue</tt><big>(</big>const ValueType&amp; <em>value</em><big>)</big><a class="headerlink" href="#qi::Promise:T:::setValue__ValueTypeCR" title="Permalink to this definition">¶</a></dt>
<dd><p>notify all future that a value has been set. throw if state != running If T is void value must be 0</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::setError__ssCR">
void <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">setError</tt><big>(</big>const std::string&amp; <em>msg</em><big>)</big><a class="headerlink" href="#qi::Promise:T:::setError__ssCR" title="Permalink to this definition">¶</a></dt>
<dd><p>set the error, and notify all futures throw if state != running</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::setCanceled">
void <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">setCanceled</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Promise:T:::setCanceled" title="Permalink to this definition">¶</a></dt>
<dd><p>set the cancel state, and notify all futures throw if state != running</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::isCancelRequested">
bool <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">isCancelRequested</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Promise:T:::isCancelRequested" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if cancel has been called on the promise (even if the cancel callback did not run yet).</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::reset">
void <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Promise:T:::reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset the promise and the future Deprecatedreseting a promise removes connect() guaranties</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::futureC">
Future&lt;T&gt; <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">future</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::Promise:T:::futureC" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a future linked to this promise. Can be called multiple times.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::value">
ValueType&amp; <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">value</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Promise:T:::value" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives access to the underlying value for in-place modification. trigger() must be called after the value is written to trigger the promise.</p>
</dd></dl>

<dl class="function">
<dt id="qi::Promise:T:::trigger">
void <tt class="descclassname">qi::Promise&lt;T&gt;::</tt><tt class="descname">trigger</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::Promise:T:::trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigger the promise with the current value.</p>
</dd></dl>

</div>
</div>
<div class="section" id="qi-futuresync-class-reference">
<h3>qi::FutureSync Class Reference<a class="headerlink" href="#qi-futuresync-class-reference" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p> <a class="reference external" href="#detailed-description"><tt class="docutils literal"><span class="pre">More...</span></tt></a></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;qi/future.hpp&gt;</span>
</pre></div>
</div>
<ul class="simple">
</ul>
</div>
<div class="section" id="public-functions">
<h4>Public Functions<a class="headerlink" href="#public-functions" title="Permalink to this headline">¶</a></h4>
<dl class="function function-index">
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::FutureSync"><tt class="xref cpp cpp-func docutils literal"><span class="pre">FutureSync</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::FutureSync__Future:T:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">FutureSync</span></tt></a></tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::FutureSync__FutureSync:T:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">FutureSync</span></tt></a></tt><big>(</big>const FutureSync&lt;T&gt;&amp; <em>b</em><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::FutureSync__ValueTypeCR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">FutureSync</span></tt></a></tt><big>(</big>const ValueType&amp; <em>v</em><big>)</big></dt>
<dt>
<span>FutureSync&lt;T&gt;&amp;</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::assign-operator__FutureSync:T:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator=</span></tt></a></tt><big>(</big>const FutureSync&lt;T&gt;&amp; <em>b</em><big>)</big></dt>
<dt>
<span>FutureSync&lt;T&gt;&amp;</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::assign-operator__Future:T:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator=</span></tt></a></tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::~FutureSync"><tt class="xref cpp cpp-func docutils literal"><span class="pre">~FutureSync</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::castto-Future:T:-operator"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator</span> <span class="pre">Future&lt;T&gt;</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::lt-operator__FutureSync:T:CRC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">operator&lt;</span></tt></a></tt><big>(</big>const FutureSync&lt;T&gt;&amp; <em>b</em><big>)</big> const</dt>
<dt>
<span>const ValueType&amp;</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::value__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">value</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span></span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::castto-typename-Future:T:::ValueTypeCastCR-operatorC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">ValueTypeCast&amp;</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>FutureState</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::wait__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">wait</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>FutureState</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::wait__qi::DurationC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">wait</span></tt></a></tt><big>(</big>qi::Duration <em>duration</em><big>)</big> const</dt>
<dt>
<span>FutureState</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::wait__qi::SteadyClock::time_pointC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">wait</span></tt></a></tt><big>(</big>qi::SteadyClock::time_point <em>timepoint</em><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::isRunningC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isRunning</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::isFinishedC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isFinished</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::isCanceledC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isCanceled</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::hasError__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">hasError</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::hasValue__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">hasValue</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>const std::string&amp;</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::error__iC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">error</span></tt></a></tt><big>(</big>int <em>msecs</em><big>)</big> const</dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::cancel"><tt class="xref cpp cpp-func docutils literal"><span class="pre">cancel</span></tt></a></tt><big>(</big><big>)</big></dt>
<dt>
<span>bool</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::isCancelableC"><tt class="xref cpp cpp-func docutils literal"><span class="pre">isCancelable</span></tt></a></tt><big>(</big><big>)</big> const</dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::connect__ConnectionCR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">connect</span></tt></a></tt><big>(</big>const Connection&amp; <em>s</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::_connect__boost::function:void:CR"><tt class="xref cpp cpp-func docutils literal"><span class="pre">_connect</span></tt></a></tt><big>(</big>const boost::function&lt;void()&gt;&amp; <em>s</em><big>)</big></dt>
<dt>
<span>void</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::connect__FUNCTYPE.ARG0.X"><tt class="xref cpp cpp-func docutils literal"><span class="pre">connect</span></tt></a></tt><big>(</big>FUNCTYPE <em>fun</em>, ARG0 <em>tracked</em>, <em>...</em><big>)</big></dt>
<dt>
<span>Future&lt;T&gt;</span> <tt class="descname"><a class="reference external" href="#qi::FutureSync:T:::async"><tt class="xref cpp cpp-func docutils literal"><span class="pre">async</span></tt></a></tt><big>(</big><big>)</big></dt>
</dl>

</div>
<div class="section" id="types">
<h4>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h4>
<dl class="type">
<dt id="TPD_qi::FutureSync::ValueType">
<!--[TPD_qi::FutureSync::ValueType]--><span><em>typedef </em>Future&lt; T &gt;::ValueType</span> <span>ValueType</span><a class="headerlink" href="#TPD_qi::FutureSync::ValueType" title="Permalink to this definition">¶</a></dt>
<span>

        

        </span><dt id="TPD_qi::FutureSync::ValueTypeCast">
<span><em>typedef </em>Future&lt; T &gt;::ValueTypeCast</span> <span>ValueTypeCast</span><a class="headerlink" href="#TPD_qi::FutureSync::ValueTypeCast" title="Permalink to this definition">¶</a></dt>
<span>

        

        </span><dt id="TPD_qi::FutureSync::Connection">
<span><em>typedef </em>Future&lt; T &gt;::Connection</span> <span>Connection</span><a class="headerlink" href="#TPD_qi::FutureSync::Connection" title="Permalink to this definition">¶</a></dt>
<span>

        

        </span></dl>

</div>
<div class="section" id="detailed-description">
<h4>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h4>
<p><p>This class allow throwing on error and being synchronous when the future is not handled by the client.</p>
<p>This class should only be used as return type. If you want to store it, use qi::Future.</p>
</p>
</div>
<div class="section" id="function-documentation">
<h4>Function Documentation<a class="headerlink" href="#function-documentation" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="qi::FutureSync:T:::FutureSync">
 <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">FutureSync</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::FutureSync" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::FutureSync__Future:T:CR">
 <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">FutureSync</tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::FutureSync__Future:T:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::FutureSync__FutureSync:T:CR">
 <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">FutureSync</tt><big>(</big>const FutureSync&lt;T&gt;&amp; <em>b</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::FutureSync__FutureSync:T:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::FutureSync__ValueTypeCR">
 <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">FutureSync</tt><big>(</big>const ValueType&amp; <em>v</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::FutureSync__ValueTypeCR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::assign-operator__FutureSync:T:CR">
FutureSync&lt;T&gt;&amp; <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">operator=</tt><big>(</big>const FutureSync&lt;T&gt;&amp; <em>b</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::assign-operator__FutureSync:T:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::assign-operator__Future:T:CR">
FutureSync&lt;T&gt;&amp; <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">operator=</tt><big>(</big>const Future&lt;T&gt;&amp; <em>b</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::assign-operator__Future:T:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::~FutureSync">
 <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">~FutureSync</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::~FutureSync" title="Permalink to this definition">¶</a></dt>
<dd><p>will block until the future returns if the future is kept synchronous</p>
</dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::castto-Future:T:-operator">
 <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">operator</tt> Future&lt;T&gt;<big>(</big><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::castto-Future:T:-operator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::lt-operator__FutureSync:T:CRC">
bool <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">operator&lt;</tt><big>(</big>const FutureSync&lt;T&gt;&amp; <em>b</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::lt-operator__FutureSync:T:CRC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::value__iC">
const ValueType&amp; <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">value</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::value__iC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::castto-typename-Future:T:::ValueTypeCastCR-operatorC">
 <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">operator</tt> const typename Future&lt;T&gt;::ValueTypeCast&amp;<big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::castto-typename-Future:T:::ValueTypeCastCR-operatorC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::wait__iC">
FutureState <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">wait</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::wait__iC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::wait__qi::DurationC">
FutureState <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">wait</tt><big>(</big><a class="reference external" href="clock.html#TPD_qi::Duration">qi::Duration</a> <em>duration</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::wait__qi::DurationC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::wait__qi::SteadyClock::time_pointC">
FutureState <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">wait</tt><big>(</big><a class="reference external" href="clock.html#TPD_qi::SteadyClock::time_point">qi::SteadyClock::time_point</a> <em>timepoint</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::wait__qi::SteadyClock::time_pointC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::isRunningC">
bool <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">isRunning</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::isRunningC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::isFinishedC">
bool <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">isFinished</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::isFinishedC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::isCanceledC">
bool <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">isCanceled</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::isCanceledC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::hasError__iC">
bool <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">hasError</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::hasError__iC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::hasValue__iC">
bool <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">hasValue</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::hasValue__iC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::error__iC">
const std::string&amp; <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">error</tt><big>(</big>int <em>msecs</em> = FutureTimeout_Infinite<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::error__iC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::cancel">
void <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">cancel</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::cancel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::isCancelableC">
bool <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">isCancelable</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#qi::FutureSync:T:::isCancelableC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::connect__ConnectionCR">
void <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">connect</tt><big>(</big>const Connection&amp; <em>s</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::connect__ConnectionCR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::_connect__boost::function:void:CR">
void <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">_connect</tt><big>(</big>const boost::function&lt;void()&gt;&amp; <em>s</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::_connect__boost::function:void:CR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::connect__FUNCTYPE.ARG0.X">
void <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">connect</tt><big>(</big>FUNCTYPE <em>fun</em>, ARG0 <em>tracked</em>, <em>...</em><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::connect__FUNCTYPE.ARG0.X" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect a callback with binding and tracking support.</p>
<p>If the first argument is a weak_ptr or a pointer inheriting from qi::Trackable, the callback will not be called if tracked object was destroyed.</p>
</dd></dl>

<dl class="function">
<dt id="qi::FutureSync:T:::async">
Future&lt;T&gt; <tt class="descclassname">qi::FutureSync&lt;T&gt;::</tt><tt class="descname">async</tt><big>(</big><big>)</big><a class="headerlink" href="#qi::FutureSync:T:::async" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>
<dl class="function">
<dt id="qi::PromiseNoop__X">
void <tt class="descclassname">qi::</tt><tt class="descname">PromiseNoop</tt><big>(</big><em>const qi::Promise&lt;T&gt;&amp;</em><big>)</big><a class="headerlink" href="#qi::PromiseNoop__X" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that does nothing on future cancellation.</p>
</dd></dl>

</div>
</div>


          </div>
          <div class="footernav">
    &laquo; <a href="eventloop.html" title="qi::EventLoop">qi::EventLoop</a>
     |
    <a href="index.html" title="C++ qi API Reference" accesskey="U">C++ qi API Reference</a>
   |
    <a href="iocolor.html" title="qi::IOColor">qi::IOColor</a> &raquo;</div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>


  <h3>Table Of Contents</h3>
  <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API References</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">C++ qi API Reference</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="actor.html">qi::Actor and qi::Strand</a></li>
<li class="toctree-l3"><a class="reference internal" href="application.html">qi::Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="applicationsession.html">qi::ApplicationSession</a></li>
<li class="toctree-l3"><a class="reference internal" href="anyvalue.html">qi::AnyValue</a></li>
<li class="toctree-l3"><a class="reference internal" href="anyfunction.html">qi::AnyFunction</a></li>
<li class="toctree-l3"><a class="reference internal" href="anyobject.html">qi::Object</a></li>
<li class="toctree-l3"><a class="reference internal" href="anymodule.html">qi::AnyModule</a></li>
<li class="toctree-l3"><a class="reference internal" href="atomic.html">qi::Atomic</a></li>
<li class="toctree-l3"><a class="reference internal" href="buffer.html">qi::Buffer, qi::BufferReader</a></li>
<li class="toctree-l3"><a class="reference internal" href="binarycodec.html">Binary Codec</a></li>
<li class="toctree-l3"><a class="reference internal" href="clock.html">qi::Clock</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamicobjectbuilder.html">qi::DynamicObjectBuilder</a></li>
<li class="toctree-l3"><a class="reference internal" href="eventloop.html">qi::EventLoop</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">qi::Promise, qi::Future</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="iocolor.html">qi::IOColor</a></li>
<li class="toctree-l3"><a class="reference internal" href="jsoncodec.html">JSON Codec</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">qi::log</a></li>
<li class="toctree-l3"><a class="reference internal" href="macro.html">qi helper macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="metaobject.html">qi::MetaObject, qi::MetaMethod, qi::MetaSignal, qi::MetaProperty</a></li>
<li class="toctree-l3"><a class="reference internal" href="objecttypebuilder.html">qi::ObjectTypeBuilder</a></li>
<li class="toctree-l3"><a class="reference internal" href="os.html">qi::os</a></li>
<li class="toctree-l3"><a class="reference internal" href="path.html">qi::path namespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="periodictask.html">qi::PeriodicTask</a></li>
<li class="toctree-l3"><a class="reference internal" href="preproc.html">qi preprocessor macros</a></li>
<li class="toctree-l3"><a class="reference internal" href="property.html">qi::Property</a></li>
<li class="toctree-l3"><a class="reference internal" href="session.html">qi::Session</a></li>
<li class="toctree-l3"><a class="reference internal" href="signal.html">qi::Signal</a></li>
<li class="toctree-l3"><a class="reference internal" href="signature.html">qi::Signature</a></li>
<li class="toctree-l3"><a class="reference internal" href="stats.html">qi::stats namespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="trackable.html">qi::Trackable</a></li>
<li class="toctree-l3"><a class="reference internal" href="translator.html">qi::Translator</a></li>
<li class="toctree-l3"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="url.html">qi::Url</a></li>
<li class="toctree-l3"><a class="reference internal" href="version.html">qi::Version</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cpp-classindex.html">C++ Class Index</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../cpp-funcindex.html">C++ Function Index</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../python/index.html">Python qi API reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../guide/index.html">User Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../design/index.html">Design Documents</a></li>
</ul>

    <h3><a href="../../index.html">On this page</a></h3>
    <ul>
<li><a class="reference internal" href="#">qi::Promise, qi::Future</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a><ul>
<li><a class="reference internal" href="#qi-future">qi::Future</a><ul>
<li><a class="reference internal" href="#the-different-states-of-a-future">The different states of a Future</a></li>
<li><a class="reference internal" href="#getting-the-state-and-waiting-for-a-future">Getting the state and waiting for a Future</a></li>
<li><a class="reference internal" href="#future-notification">Future notification</a></li>
<li><a class="reference internal" href="#future-cancellation">Future cancellation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#qi-promise">qi::Promise</a><ul>
<li><a class="reference internal" href="#supporting-cancellation">Supporting cancellation</a></li>
<li><a class="reference internal" href="#controlling-callback-execution">Controlling callback execution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#qi-futuresync">qi::FutureSync</a><ul>
<li><a class="reference internal" href="#returning-a-futuresync">Returning a FutureSync</a></li>
<li><a class="reference internal" href="#calling-a-function-returning-a-futuresync">Calling a function returning a FutureSync</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-an-asynchronous-function">Implementing an asynchronous function</a><ul>
<li><a class="reference internal" href="#simple-implementation">Simple implementation</a></li>
<li><a class="reference internal" href="#cancellation-support">Cancellation support</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reference">Reference</a><ul>
<li><a class="reference internal" href="#qi-future-class-reference">qi::Future Class Reference</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#public-functions">Public Functions</a></li>
<li><a class="reference internal" href="#types">Types</a></li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
<li><a class="reference internal" href="#function-documentation">Function Documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#qi-promise-class-reference">qi::Promise Class Reference</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#public-functions">Public Functions</a></li>
<li><a class="reference internal" href="#types">Types</a></li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
<li><a class="reference internal" href="#function-documentation">Function Documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#qi-futuresync-class-reference">qi::FutureSync Class Reference</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#public-functions">Public Functions</a></li>
<li><a class="reference internal" href="#types">Types</a></li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
<li><a class="reference internal" href="#function-documentation">Function Documentation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="eventloop.html" title="qi::EventLoop">previous</a>
     |
    <a href="index.html" title="C++ qi API Reference" accesskey="U">up</a>
   |
    <a href="iocolor.html" title="qi::IOColor">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>