
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Registering types in the type system &mdash; qi SDK Documentation 2.2.0.55 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.2.0.55',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="qi SDK Documentation 2.2.0.55 documentation" href="../index.html" />
    <link rel="up" title="User Guides" href="index.html" />
    <link rel="next" title="Asynchronous operations" href="cxx-async.html" />
    <link rel="prev" title="How to write a qimessaging service in C++" href="cxx-service.html" />
 
<script>
$(window).ready(function () {
    var width_label = 0;
    $('dl.function-index dt > span').each(function () {
        $(this).css('width', 'auto');
        width_label = Math.max(width_label, $(this).width());
    }).width(width_label + 30);
    $('.sig-paren').width('auto');
})

</script>


<script type="text/javascript" src="/static/js/ga-status.js"></script>



  </head>
  <body>

    <div class="document">
  <div id="custom-doc" class="yui-t3">
    <div id="hd">
      <h1><a href="../index.html">qi SDK Documentation 2.2.0.55 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">Home</a>
         |
        <a title="Site map" href="../contents.html">Site map</a>
         |
        <a title="Search" href="../search.html">Search</a>
         |
        <a title="Index" href="../genindex.html">Index</a>
      </div>
      <div class="nav">
    &laquo; <a href="cxx-service.html" title="How to write a qimessaging service in C++">previous</a>
     |
    <a href="index.html" title="User Guides" accesskey="U">up</a>
   |
    <a href="cxx-async.html" title="Asynchronous operations">next</a> &raquo;</div>
    </div>

    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="guide-cxx-register-types">
            
  <div class="section" id="registering-types-in-the-type-system">
<span id="guide-cxx-register-types"></span><h1>Registering types in the type system<a class="headerlink" href="#registering-types-in-the-type-system" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>For types to be available in the type system and allow them to be type-erased,
sent over the network or through signals, each one of them needs to be
registered in the type system.</p>
<p>Most of these registration can be done through macros. It is very important
that you call macros made to be used in .cpp only in .cpp files, these macros
should be processed in a single translation unit.</p>
<p>All registration classes and macros are in:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;qi/anyobject.hpp&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="structures">
<h2>Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<p>To register a structure, you need to call the macro <tt class="xref cpp cpp-guess docutils literal"><span class="pre">QI_TYPE_STRUCT()</span></tt> in the
corresponding .hpp file.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// point.hpp</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="n">QI_TYPE_STRUCT</span><span class="p">(</span><span class="n">Graph</span><span class="o">::</span><span class="n">Point</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>Or you can do the register in the .cpp:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// point.cpp</span>

<span class="c1">// call this outside of any namespace</span>
<span class="n">QI_TYPE_STRUCT_REGISTER</span><span class="p">(</span><span class="n">Graph</span><span class="o">::</span><span class="n">Point</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="using-pimpl-in-structures">
<h3>Using PIMPL in structures<a class="headerlink" href="#using-pimpl-in-structures" title="Permalink to this headline">¶</a></h3>
<p>Sometime, you have a structure of data, but you don&#8217;t want the user to access
it directly because you want to constrain values or to updates multiple values
at the same time so that the structure stays coherent.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">setValues</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
      <span class="n">_length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">float</span> <span class="n">length</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_length</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ...</span>

  <span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">_x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">_y</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">_length</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// How can I register this??</span>
</pre></div>
</div>
<p>You can&#8217;t register this struct because _x, _y and _length are private and you
don&#8217;t want to make them public because the user could change _x and _y without
changing _length.</p>
<p>To register that to the type system, you need to use pimpl:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// vector.hpp</span>

<span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">Vector</span><span class="p">();</span>
    <span class="c1">// you need a copy constructor because qitype makes copies</span>
    <span class="n">Vector</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setValues</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="kt">float</span> <span class="nf">length</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

  <span class="nl">private:</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="k">struct</span> <span class="n">VectorPrivate</span><span class="o">&gt;</span> <span class="n">_p</span><span class="p">;</span>

    <span class="c1">// you need this for later</span>
    <span class="k">friend</span> <span class="k">struct</span> <span class="n">VectorPrivate</span><span class="o">*</span> <span class="nf">vectorPrivateAccess</span><span class="p">(</span><span class="n">Vector</span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// vector.cpp</span>

<span class="k">struct</span> <span class="n">VectorPrivate</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">_y</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">_length</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Vector</span><span class="o">::</span><span class="n">Vector</span><span class="p">()</span> <span class="o">:</span> <span class="n">_p</span><span class="p">(</span><span class="k">new</span> <span class="n">VectorPrivate</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">Vector</span><span class="o">::</span><span class="n">Vector</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">_p</span><span class="p">(</span><span class="k">new</span> <span class="n">VectorPrivate</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">_p</span><span class="p">))</span> <span class="p">{}</span>
</pre></div>
</div>
<p>Then you can register the private part of the struct and tell qitype how to
access it:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">VectorPrivate</span><span class="o">*</span> <span class="nf">vectorPrivateAccess</span><span class="p">(</span><span class="n">Vector</span><span class="o">*</span> <span class="n">vector</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">vector</span><span class="o">-&gt;</span><span class="n">_p</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// call these outside of any namespace</span>
<span class="n">QI_TYPE_STRUCT_REGISTER</span><span class="p">(</span><span class="n">VectorPrivate</span><span class="p">,</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_length</span><span class="p">);</span>

<span class="n">QI_TYPE_STRUCT_BOUNCE_REGISTER</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">VectorPrivate</span><span class="p">,</span> <span class="n">vectorPrivateAccess</span><span class="p">);</span>
</pre></div>
</div>
<p>Everytime you transfer a Vector, qimessaging will also transfer its private
part and no one can access it without using the accessors.</p>
</div>
</div>
<div class="section" id="enums">
<h2>Enums<a class="headerlink" href="#enums" title="Permalink to this headline">¶</a></h2>
<p>Enums are easy to register:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// color.hpp</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span>
    <span class="n">Red</span><span class="p">,</span>
    <span class="n">Green</span><span class="p">,</span>
    <span class="n">Blue</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// call this outside of any namespace</span>
<span class="n">QI_TYPE_ENUM_REGISTER</span><span class="p">(</span><span class="n">Graph</span><span class="o">::</span><span class="n">Color</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="using-registration-helper">
<h3>Using registration helper<a class="headerlink" href="#using-registration-helper" title="Permalink to this headline">¶</a></h3>
<p>Classes can only be registered in .cpp files:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// drawer.hpp</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">Drawer</span> <span class="p">{</span>
    <span class="nl">public:</span>
      <span class="kt">bool</span> <span class="n">draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="n">Color</span> <span class="n">color</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Drawing point&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">drawDone</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">qi</span><span class="o">::</span><span class="n">Signal</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">drawDone</span><span class="p">;</span>

      <span class="n">qi</span><span class="o">::</span><span class="n">Property</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">origin</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// drawer.cpp</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="c1">// call this from inside the namespace of the class</span>
  <span class="n">QI_REGISTER_OBJECT</span><span class="p">(</span><span class="n">Drawer</span><span class="p">,</span> <span class="n">draw</span><span class="p">,</span> <span class="n">drawDone</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are two threading models for classes. <tt class="xref cpp cpp-guess docutils literal"><span class="pre">Drawer</span></tt> is registered as
single threaded in the above example. When doing multiple calls of its
methods in parallel, they will be sequenced. If you need your object to support
multithreaded calls, use the MT macro:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// drawer.cpp</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="c1">// call this from inside the namespace of the class</span>
  <span class="n">QI_REGISTER_MT_OBJECT</span><span class="p">(</span><span class="n">Drawer</span><span class="p">,</span> <span class="n">draw</span><span class="p">,</span> <span class="n">drawDone</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="doing-it-manually">
<span id="guide-cxx-register-types-object-manual"></span><h3>Doing it manually<a class="headerlink" href="#doing-it-manually" title="Permalink to this headline">¶</a></h3>
<p>The helper won&#8217;t always allow you to register a class, for example when you
have method overloading in your class. In these cases, you need to register
your type manually with <a class="reference internal" href="../api/cpp/objecttypebuilder.html#qi::ObjectTypeBuilder" title="qi::ObjectTypeBuilder"><tt class="xref cpp cpp-guess docutils literal"><span class="pre">qi::ObjectTypeBuilder</span></tt></a> so that you can specify the
signature of the function.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// drawer.hpp</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">Drawer</span> <span class="p">{</span>
    <span class="nl">public:</span>
      <span class="kt">bool</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Initializing drawer&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span> <span class="n">Color</span> <span class="n">color</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Drawing point with color&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Drawing point&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">qi</span><span class="o">::</span><span class="n">Signal</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">objectDrawn</span><span class="p">;</span>
      <span class="n">qi</span><span class="o">::</span><span class="n">Property</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">objectCount</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// drawer.cpp</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="c1">// this won&#39;t work because we can&#39;t differenciate the two draw methods</span>
  <span class="c1">//QI_REGISTER_OBJECT(Drawer, draw, draw);</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">Graph</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">_qiregisterDrawer</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">qi</span><span class="o">::</span><span class="n">ObjectTypeBuilder</span><span class="o">&lt;</span><span class="n">Drawer</span><span class="o">&gt;</span> <span class="n">builder</span><span class="p">;</span>
    <span class="c1">// use static_cast to remove ambiguity between overloads</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">advertiseMethod</span><span class="p">(</span><span class="s">&quot;draw&quot;</span><span class="p">,</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="n">Drawer</span><span class="o">::*</span><span class="p">)(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Drawer</span><span class="o">::</span><span class="n">draw</span><span class="p">));</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">advertiseMethod</span><span class="p">(</span><span class="s">&quot;draw&quot;</span><span class="p">,</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="n">Drawer</span><span class="o">::*</span><span class="p">)(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Drawer</span><span class="o">::</span><span class="n">draw</span><span class="p">));</span>
    <span class="c1">// no need to static_cast if there is no overload</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">advertiseMethod</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Drawer</span><span class="o">::</span><span class="n">init</span><span class="p">);</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">advertiseSignal</span><span class="p">(</span><span class="s">&quot;objectDrawn&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Drawer</span><span class="o">::</span><span class="n">objectDrawn</span><span class="p">);</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">advertiseProperty</span><span class="p">(</span><span class="s">&quot;objectCount&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Drawer</span><span class="o">::</span><span class="n">objectCount</span><span class="p">);</span>
    <span class="n">builder</span><span class="p">.</span><span class="n">registerType</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">__qi_registrationDrawer</span> <span class="o">=</span> <span class="n">_qiregisterDrawer</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="more-on-threading-model">
<h3>More on Threading Model<a class="headerlink" href="#more-on-threading-model" title="Permalink to this headline">¶</a></h3>
<p>If you need your object to be multithreaded, set it on your builder:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">builder</span><span class="p">.</span><span class="n">setThreadingModel</span><span class="p">(</span><span class="n">qi</span><span class="o">::</span><span class="n">ObjectThreadingModel_MultiThread</span><span class="p">);</span>
</pre></div>
</div>
<p>It is also possible to have a single-threaded class on which only some methods
are multithreaded:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">builder</span><span class="p">.</span><span class="n">advertiseMethod</span><span class="p">(</span><span class="s">&quot;multiThreadedMethod&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Drawer</span><span class="o">::</span><span class="n">multiThreadedMethod</span><span class="p">,</span>
    <span class="n">qi</span><span class="o">::</span><span class="n">MetaCallType_Queued</span><span class="p">);</span>
</pre></div>
</div>
<p>If you also want non-type-erased calls to be single-threaded (on async,
signals, etc), you must inherit from <tt class="xref cpp cpp-guess docutils literal"><span class="pre">Actor</span></tt>. See <a class="reference internal" href="../api/cpp/actor.html#api-actor"><em>qi::Actor and qi::Strand</em></a>.</p>
</div>
</div>
<div class="section" id="factories">
<h2>Factories<a class="headerlink" href="#factories" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, you may need to create objects from a type-erased context.
Registering classes is not enough to instantiate them through the
type system. For that, you need to register factories in the .cpp file. To
register a factory which will just call the default constructor, use:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// drawer.cpp</span>

<span class="c1">// you can put that in a namespace</span>
<span class="n">QI_REGISTER_OBJECT_FACTORY_CONSTRUCTOR</span><span class="p">(</span><span class="n">Graph</span><span class="o">::</span><span class="n">Drawer</span><span class="p">);</span>
</pre></div>
</div>
<p>This will create a factory named <tt class="docutils literal"><span class="pre">&quot;Graph::Drawer&quot;</span></tt>. If you want a different
name, you can use:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">QI_REGISTER_OBJECT_FACTORY_CONSTRUCTOR_FOR</span><span class="p">(</span><span class="s">&quot;MyDrawer&quot;</span><span class="p">,</span> <span class="n">Graph</span><span class="o">::</span><span class="n">Drawer</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Factories are unique. You can&#8217;t have two factories with the same name!</p>
</div>
<p>If you want to pass arguments to the constructor, you need to specify the
signature to the macro:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// drawer.hpp</span>

<span class="k">class</span> <span class="nc">Drawer</span> <span class="p">{</span>
  <span class="n">Drawer</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// drawer.cpp</span>

<span class="n">QI_REGISTER_OBJECT_FACTORY_CONSTRUCTOR</span><span class="p">(</span><span class="n">Drawer</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <div class="footernav">
    &laquo; <a href="cxx-service.html" title="How to write a qimessaging service in C++">How to write a qimessaging service in C++</a>
     |
    <a href="index.html" title="User Guides" accesskey="U">User Guides</a>
   |
    <a href="cxx-async.html" title="Asynchronous operations">Asynchronous operations</a> &raquo;</div>
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>


  <h3>Table Of Contents</h3>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API References</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="cxx-client.html">How to write a qimessaging client in C++</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxx-service.html">How to write a qimessaging service in C++</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Registering types in the type system</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cxx-async.html">Asynchronous operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxx-log.html">Using qi::log</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxx-linguist.html">Internationalization Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxx-path.html">Handling Paths Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxx-path.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxx-path.html#using-namespace-path">Using Namespace path</a></li>
<li class="toctree-l2"><a class="reference internal" href="cxx-path.html#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="py-client.html">How to write a qimessaging client in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="py-service.html">How to write a qimessaging service in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="py-tonaoqi2.html">How to switch from NAOqi1 to NAOqi2</a></li>
<li class="toctree-l2"><a class="reference internal" href="py-log-client.html">How to receive and send logs in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="qi-package-services.html">Packaging services in an application</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../design/index.html">Design Documents</a></li>
</ul>

    <h3><a href="../index.html">On this page</a></h3>
    <ul>
<li><a class="reference internal" href="#">Registering types in the type system</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#structures">Structures</a><ul>
<li><a class="reference internal" href="#using-pimpl-in-structures">Using PIMPL in structures</a></li>
</ul>
</li>
<li><a class="reference internal" href="#enums">Enums</a></li>
<li><a class="reference internal" href="#classes">Classes</a><ul>
<li><a class="reference internal" href="#using-registration-helper">Using registration helper</a></li>
<li><a class="reference internal" href="#doing-it-manually">Doing it manually</a></li>
<li><a class="reference internal" href="#more-on-threading-model">More on Threading Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#factories">Factories</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
          </div>
        
      
    </div>

    <div id="ft">
      <div class="nav">
    &laquo; <a href="cxx-service.html" title="How to write a qimessaging service in C++">previous</a>
     |
    <a href="index.html" title="User Guides" accesskey="U">up</a>
   |
    <a href="cxx-async.html" title="Asynchronous operations">next</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>